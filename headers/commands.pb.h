// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commands.proto

#ifndef PROTOBUF_commands_2eproto__INCLUDED
#define PROTOBUF_commands_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "primitive.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_commands_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAddAssetQuantityImpl();
void InitDefaultsAddAssetQuantity();
void InitDefaultsAddPeerImpl();
void InitDefaultsAddPeer();
void InitDefaultsAddSignatoryImpl();
void InitDefaultsAddSignatory();
void InitDefaultsCreateAssetImpl();
void InitDefaultsCreateAsset();
void InitDefaultsCreateAccountImpl();
void InitDefaultsCreateAccount();
void InitDefaultsSetAccountDetailImpl();
void InitDefaultsSetAccountDetail();
void InitDefaultsCreateDomainImpl();
void InitDefaultsCreateDomain();
void InitDefaultsRemoveSignatoryImpl();
void InitDefaultsRemoveSignatory();
void InitDefaultsSetAccountQuorumImpl();
void InitDefaultsSetAccountQuorum();
void InitDefaultsTransferAssetImpl();
void InitDefaultsTransferAsset();
void InitDefaultsAppendRoleImpl();
void InitDefaultsAppendRole();
void InitDefaultsDetachRoleImpl();
void InitDefaultsDetachRole();
void InitDefaultsCreateRoleImpl();
void InitDefaultsCreateRole();
void InitDefaultsGrantPermissionImpl();
void InitDefaultsGrantPermission();
void InitDefaultsRevokePermissionImpl();
void InitDefaultsRevokePermission();
void InitDefaultsSubtractAssetQuantityImpl();
void InitDefaultsSubtractAssetQuantity();
void InitDefaultsCommandImpl();
void InitDefaultsCommand();
inline void InitDefaults() {
  InitDefaultsAddAssetQuantity();
  InitDefaultsAddPeer();
  InitDefaultsAddSignatory();
  InitDefaultsCreateAsset();
  InitDefaultsCreateAccount();
  InitDefaultsSetAccountDetail();
  InitDefaultsCreateDomain();
  InitDefaultsRemoveSignatory();
  InitDefaultsSetAccountQuorum();
  InitDefaultsTransferAsset();
  InitDefaultsAppendRole();
  InitDefaultsDetachRole();
  InitDefaultsCreateRole();
  InitDefaultsGrantPermission();
  InitDefaultsRevokePermission();
  InitDefaultsSubtractAssetQuantity();
  InitDefaultsCommand();
}
}  // namespace protobuf_commands_2eproto
namespace iroha {
namespace protocol {
class AddAssetQuantity;
class AddAssetQuantityDefaultTypeInternal;
extern AddAssetQuantityDefaultTypeInternal _AddAssetQuantity_default_instance_;
class AddPeer;
class AddPeerDefaultTypeInternal;
extern AddPeerDefaultTypeInternal _AddPeer_default_instance_;
class AddSignatory;
class AddSignatoryDefaultTypeInternal;
extern AddSignatoryDefaultTypeInternal _AddSignatory_default_instance_;
class AppendRole;
class AppendRoleDefaultTypeInternal;
extern AppendRoleDefaultTypeInternal _AppendRole_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class CreateAccount;
class CreateAccountDefaultTypeInternal;
extern CreateAccountDefaultTypeInternal _CreateAccount_default_instance_;
class CreateAsset;
class CreateAssetDefaultTypeInternal;
extern CreateAssetDefaultTypeInternal _CreateAsset_default_instance_;
class CreateDomain;
class CreateDomainDefaultTypeInternal;
extern CreateDomainDefaultTypeInternal _CreateDomain_default_instance_;
class CreateRole;
class CreateRoleDefaultTypeInternal;
extern CreateRoleDefaultTypeInternal _CreateRole_default_instance_;
class DetachRole;
class DetachRoleDefaultTypeInternal;
extern DetachRoleDefaultTypeInternal _DetachRole_default_instance_;
class GrantPermission;
class GrantPermissionDefaultTypeInternal;
extern GrantPermissionDefaultTypeInternal _GrantPermission_default_instance_;
class RemoveSignatory;
class RemoveSignatoryDefaultTypeInternal;
extern RemoveSignatoryDefaultTypeInternal _RemoveSignatory_default_instance_;
class RevokePermission;
class RevokePermissionDefaultTypeInternal;
extern RevokePermissionDefaultTypeInternal _RevokePermission_default_instance_;
class SetAccountDetail;
class SetAccountDetailDefaultTypeInternal;
extern SetAccountDetailDefaultTypeInternal _SetAccountDetail_default_instance_;
class SetAccountQuorum;
class SetAccountQuorumDefaultTypeInternal;
extern SetAccountQuorumDefaultTypeInternal _SetAccountQuorum_default_instance_;
class SubtractAssetQuantity;
class SubtractAssetQuantityDefaultTypeInternal;
extern SubtractAssetQuantityDefaultTypeInternal _SubtractAssetQuantity_default_instance_;
class TransferAsset;
class TransferAssetDefaultTypeInternal;
extern TransferAssetDefaultTypeInternal _TransferAsset_default_instance_;
}  // namespace protocol
}  // namespace iroha
namespace iroha {
namespace protocol {

// ===================================================================

class AddAssetQuantity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AddAssetQuantity) */ {
 public:
  AddAssetQuantity();
  virtual ~AddAssetQuantity();

  AddAssetQuantity(const AddAssetQuantity& from);

  inline AddAssetQuantity& operator=(const AddAssetQuantity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddAssetQuantity(AddAssetQuantity&& from) noexcept
    : AddAssetQuantity() {
    *this = ::std::move(from);
  }

  inline AddAssetQuantity& operator=(AddAssetQuantity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddAssetQuantity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddAssetQuantity* internal_default_instance() {
    return reinterpret_cast<const AddAssetQuantity*>(
               &_AddAssetQuantity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AddAssetQuantity* other);
  friend void swap(AddAssetQuantity& a, AddAssetQuantity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddAssetQuantity* New() const PROTOBUF_FINAL { return New(NULL); }

  AddAssetQuantity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddAssetQuantity& from);
  void MergeFrom(const AddAssetQuantity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddAssetQuantity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // string asset_id = 2;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 2;
  const ::std::string& asset_id() const;
  void set_asset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_id(::std::string&& value);
  #endif
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  ::std::string* mutable_asset_id();
  ::std::string* release_asset_id();
  void set_allocated_asset_id(::std::string* asset_id);

  // .iroha.protocol.Amount amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  const ::iroha::protocol::Amount& amount() const;
  ::iroha::protocol::Amount* release_amount();
  ::iroha::protocol::Amount* mutable_amount();
  void set_allocated_amount(::iroha::protocol::Amount* amount);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AddAssetQuantity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr asset_id_;
  ::iroha::protocol::Amount* amount_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsAddAssetQuantityImpl();
};
// -------------------------------------------------------------------

class AddPeer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AddPeer) */ {
 public:
  AddPeer();
  virtual ~AddPeer();

  AddPeer(const AddPeer& from);

  inline AddPeer& operator=(const AddPeer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddPeer(AddPeer&& from) noexcept
    : AddPeer() {
    *this = ::std::move(from);
  }

  inline AddPeer& operator=(AddPeer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddPeer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddPeer* internal_default_instance() {
    return reinterpret_cast<const AddPeer*>(
               &_AddPeer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AddPeer* other);
  friend void swap(AddPeer& a, AddPeer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddPeer* New() const PROTOBUF_FINAL { return New(NULL); }

  AddPeer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddPeer& from);
  void MergeFrom(const AddPeer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddPeer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iroha.protocol.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::iroha::protocol::Peer& peer() const;
  ::iroha::protocol::Peer* release_peer();
  ::iroha::protocol::Peer* mutable_peer();
  void set_allocated_peer(::iroha::protocol::Peer* peer);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AddPeer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iroha::protocol::Peer* peer_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsAddPeerImpl();
};
// -------------------------------------------------------------------

class AddSignatory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AddSignatory) */ {
 public:
  AddSignatory();
  virtual ~AddSignatory();

  AddSignatory(const AddSignatory& from);

  inline AddSignatory& operator=(const AddSignatory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddSignatory(AddSignatory&& from) noexcept
    : AddSignatory() {
    *this = ::std::move(from);
  }

  inline AddSignatory& operator=(AddSignatory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddSignatory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddSignatory* internal_default_instance() {
    return reinterpret_cast<const AddSignatory*>(
               &_AddSignatory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AddSignatory* other);
  friend void swap(AddSignatory& a, AddSignatory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddSignatory* New() const PROTOBUF_FINAL { return New(NULL); }

  AddSignatory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddSignatory& from);
  void MergeFrom(const AddSignatory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddSignatory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // bytes public_key = 2;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AddSignatory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsAddSignatoryImpl();
};
// -------------------------------------------------------------------

class CreateAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CreateAsset) */ {
 public:
  CreateAsset();
  virtual ~CreateAsset();

  CreateAsset(const CreateAsset& from);

  inline CreateAsset& operator=(const CreateAsset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateAsset(CreateAsset&& from) noexcept
    : CreateAsset() {
    *this = ::std::move(from);
  }

  inline CreateAsset& operator=(CreateAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateAsset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateAsset* internal_default_instance() {
    return reinterpret_cast<const CreateAsset*>(
               &_CreateAsset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CreateAsset* other);
  friend void swap(CreateAsset& a, CreateAsset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateAsset* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateAsset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateAsset& from);
  void MergeFrom(const CreateAsset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string asset_name = 1;
  void clear_asset_name();
  static const int kAssetNameFieldNumber = 1;
  const ::std::string& asset_name() const;
  void set_asset_name(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_name(::std::string&& value);
  #endif
  void set_asset_name(const char* value);
  void set_asset_name(const char* value, size_t size);
  ::std::string* mutable_asset_name();
  ::std::string* release_asset_name();
  void set_allocated_asset_name(::std::string* asset_name);

  // string domain_id = 2;
  void clear_domain_id();
  static const int kDomainIdFieldNumber = 2;
  const ::std::string& domain_id() const;
  void set_domain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_id(::std::string&& value);
  #endif
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  ::std::string* mutable_domain_id();
  ::std::string* release_domain_id();
  void set_allocated_domain_id(::std::string* domain_id);

  // uint32 precision = 3;
  void clear_precision();
  static const int kPrecisionFieldNumber = 3;
  ::google::protobuf::uint32 precision() const;
  void set_precision(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iroha.protocol.CreateAsset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asset_name_;
  ::google::protobuf::internal::ArenaStringPtr domain_id_;
  ::google::protobuf::uint32 precision_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsCreateAssetImpl();
};
// -------------------------------------------------------------------

class CreateAccount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CreateAccount) */ {
 public:
  CreateAccount();
  virtual ~CreateAccount();

  CreateAccount(const CreateAccount& from);

  inline CreateAccount& operator=(const CreateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateAccount(CreateAccount&& from) noexcept
    : CreateAccount() {
    *this = ::std::move(from);
  }

  inline CreateAccount& operator=(CreateAccount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateAccount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateAccount* internal_default_instance() {
    return reinterpret_cast<const CreateAccount*>(
               &_CreateAccount_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CreateAccount* other);
  friend void swap(CreateAccount& a, CreateAccount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateAccount* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateAccount* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateAccount& from);
  void MergeFrom(const CreateAccount& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateAccount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_name = 1;
  void clear_account_name();
  static const int kAccountNameFieldNumber = 1;
  const ::std::string& account_name() const;
  void set_account_name(const ::std::string& value);
  #if LANG_CXX11
  void set_account_name(::std::string&& value);
  #endif
  void set_account_name(const char* value);
  void set_account_name(const char* value, size_t size);
  ::std::string* mutable_account_name();
  ::std::string* release_account_name();
  void set_allocated_account_name(::std::string* account_name);

  // string domain_id = 2;
  void clear_domain_id();
  static const int kDomainIdFieldNumber = 2;
  const ::std::string& domain_id() const;
  void set_domain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_id(::std::string&& value);
  #endif
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  ::std::string* mutable_domain_id();
  ::std::string* release_domain_id();
  void set_allocated_domain_id(::std::string* domain_id);

  // bytes main_pubkey = 3;
  void clear_main_pubkey();
  static const int kMainPubkeyFieldNumber = 3;
  const ::std::string& main_pubkey() const;
  void set_main_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_main_pubkey(::std::string&& value);
  #endif
  void set_main_pubkey(const char* value);
  void set_main_pubkey(const void* value, size_t size);
  ::std::string* mutable_main_pubkey();
  ::std::string* release_main_pubkey();
  void set_allocated_main_pubkey(::std::string* main_pubkey);

  // @@protoc_insertion_point(class_scope:iroha.protocol.CreateAccount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_name_;
  ::google::protobuf::internal::ArenaStringPtr domain_id_;
  ::google::protobuf::internal::ArenaStringPtr main_pubkey_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsCreateAccountImpl();
};
// -------------------------------------------------------------------

class SetAccountDetail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SetAccountDetail) */ {
 public:
  SetAccountDetail();
  virtual ~SetAccountDetail();

  SetAccountDetail(const SetAccountDetail& from);

  inline SetAccountDetail& operator=(const SetAccountDetail& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetAccountDetail(SetAccountDetail&& from) noexcept
    : SetAccountDetail() {
    *this = ::std::move(from);
  }

  inline SetAccountDetail& operator=(SetAccountDetail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAccountDetail& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetAccountDetail* internal_default_instance() {
    return reinterpret_cast<const SetAccountDetail*>(
               &_SetAccountDetail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SetAccountDetail* other);
  friend void swap(SetAccountDetail& a, SetAccountDetail& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetAccountDetail* New() const PROTOBUF_FINAL { return New(NULL); }

  SetAccountDetail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetAccountDetail& from);
  void MergeFrom(const SetAccountDetail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetAccountDetail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:iroha.protocol.SetAccountDetail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsSetAccountDetailImpl();
};
// -------------------------------------------------------------------

class CreateDomain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CreateDomain) */ {
 public:
  CreateDomain();
  virtual ~CreateDomain();

  CreateDomain(const CreateDomain& from);

  inline CreateDomain& operator=(const CreateDomain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateDomain(CreateDomain&& from) noexcept
    : CreateDomain() {
    *this = ::std::move(from);
  }

  inline CreateDomain& operator=(CreateDomain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDomain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateDomain* internal_default_instance() {
    return reinterpret_cast<const CreateDomain*>(
               &_CreateDomain_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CreateDomain* other);
  friend void swap(CreateDomain& a, CreateDomain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateDomain* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateDomain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateDomain& from);
  void MergeFrom(const CreateDomain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateDomain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string domain_id = 1;
  void clear_domain_id();
  static const int kDomainIdFieldNumber = 1;
  const ::std::string& domain_id() const;
  void set_domain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_id(::std::string&& value);
  #endif
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  ::std::string* mutable_domain_id();
  ::std::string* release_domain_id();
  void set_allocated_domain_id(::std::string* domain_id);

  // string default_role = 2;
  void clear_default_role();
  static const int kDefaultRoleFieldNumber = 2;
  const ::std::string& default_role() const;
  void set_default_role(const ::std::string& value);
  #if LANG_CXX11
  void set_default_role(::std::string&& value);
  #endif
  void set_default_role(const char* value);
  void set_default_role(const char* value, size_t size);
  ::std::string* mutable_default_role();
  ::std::string* release_default_role();
  void set_allocated_default_role(::std::string* default_role);

  // @@protoc_insertion_point(class_scope:iroha.protocol.CreateDomain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr domain_id_;
  ::google::protobuf::internal::ArenaStringPtr default_role_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsCreateDomainImpl();
};
// -------------------------------------------------------------------

class RemoveSignatory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RemoveSignatory) */ {
 public:
  RemoveSignatory();
  virtual ~RemoveSignatory();

  RemoveSignatory(const RemoveSignatory& from);

  inline RemoveSignatory& operator=(const RemoveSignatory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveSignatory(RemoveSignatory&& from) noexcept
    : RemoveSignatory() {
    *this = ::std::move(from);
  }

  inline RemoveSignatory& operator=(RemoveSignatory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveSignatory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveSignatory* internal_default_instance() {
    return reinterpret_cast<const RemoveSignatory*>(
               &_RemoveSignatory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RemoveSignatory* other);
  friend void swap(RemoveSignatory& a, RemoveSignatory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveSignatory* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoveSignatory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoveSignatory& from);
  void MergeFrom(const RemoveSignatory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoveSignatory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // bytes public_key = 2;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:iroha.protocol.RemoveSignatory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsRemoveSignatoryImpl();
};
// -------------------------------------------------------------------

class SetAccountQuorum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SetAccountQuorum) */ {
 public:
  SetAccountQuorum();
  virtual ~SetAccountQuorum();

  SetAccountQuorum(const SetAccountQuorum& from);

  inline SetAccountQuorum& operator=(const SetAccountQuorum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetAccountQuorum(SetAccountQuorum&& from) noexcept
    : SetAccountQuorum() {
    *this = ::std::move(from);
  }

  inline SetAccountQuorum& operator=(SetAccountQuorum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAccountQuorum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetAccountQuorum* internal_default_instance() {
    return reinterpret_cast<const SetAccountQuorum*>(
               &_SetAccountQuorum_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SetAccountQuorum* other);
  friend void swap(SetAccountQuorum& a, SetAccountQuorum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetAccountQuorum* New() const PROTOBUF_FINAL { return New(NULL); }

  SetAccountQuorum* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetAccountQuorum& from);
  void MergeFrom(const SetAccountQuorum& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetAccountQuorum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // uint32 quorum = 2;
  void clear_quorum();
  static const int kQuorumFieldNumber = 2;
  ::google::protobuf::uint32 quorum() const;
  void set_quorum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iroha.protocol.SetAccountQuorum)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::uint32 quorum_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsSetAccountQuorumImpl();
};
// -------------------------------------------------------------------

class TransferAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.TransferAsset) */ {
 public:
  TransferAsset();
  virtual ~TransferAsset();

  TransferAsset(const TransferAsset& from);

  inline TransferAsset& operator=(const TransferAsset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferAsset(TransferAsset&& from) noexcept
    : TransferAsset() {
    *this = ::std::move(from);
  }

  inline TransferAsset& operator=(TransferAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferAsset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferAsset* internal_default_instance() {
    return reinterpret_cast<const TransferAsset*>(
               &_TransferAsset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TransferAsset* other);
  friend void swap(TransferAsset& a, TransferAsset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferAsset* New() const PROTOBUF_FINAL { return New(NULL); }

  TransferAsset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransferAsset& from);
  void MergeFrom(const TransferAsset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransferAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string src_account_id = 1;
  void clear_src_account_id();
  static const int kSrcAccountIdFieldNumber = 1;
  const ::std::string& src_account_id() const;
  void set_src_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_src_account_id(::std::string&& value);
  #endif
  void set_src_account_id(const char* value);
  void set_src_account_id(const char* value, size_t size);
  ::std::string* mutable_src_account_id();
  ::std::string* release_src_account_id();
  void set_allocated_src_account_id(::std::string* src_account_id);

  // string dest_account_id = 2;
  void clear_dest_account_id();
  static const int kDestAccountIdFieldNumber = 2;
  const ::std::string& dest_account_id() const;
  void set_dest_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_account_id(::std::string&& value);
  #endif
  void set_dest_account_id(const char* value);
  void set_dest_account_id(const char* value, size_t size);
  ::std::string* mutable_dest_account_id();
  ::std::string* release_dest_account_id();
  void set_allocated_dest_account_id(::std::string* dest_account_id);

  // string asset_id = 3;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 3;
  const ::std::string& asset_id() const;
  void set_asset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_id(::std::string&& value);
  #endif
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  ::std::string* mutable_asset_id();
  ::std::string* release_asset_id();
  void set_allocated_asset_id(::std::string* asset_id);

  // string description = 4;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .iroha.protocol.Amount amount = 5;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 5;
  const ::iroha::protocol::Amount& amount() const;
  ::iroha::protocol::Amount* release_amount();
  ::iroha::protocol::Amount* mutable_amount();
  void set_allocated_amount(::iroha::protocol::Amount* amount);

  // @@protoc_insertion_point(class_scope:iroha.protocol.TransferAsset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr src_account_id_;
  ::google::protobuf::internal::ArenaStringPtr dest_account_id_;
  ::google::protobuf::internal::ArenaStringPtr asset_id_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::iroha::protocol::Amount* amount_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsTransferAssetImpl();
};
// -------------------------------------------------------------------

class AppendRole : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AppendRole) */ {
 public:
  AppendRole();
  virtual ~AppendRole();

  AppendRole(const AppendRole& from);

  inline AppendRole& operator=(const AppendRole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendRole(AppendRole&& from) noexcept
    : AppendRole() {
    *this = ::std::move(from);
  }

  inline AppendRole& operator=(AppendRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendRole* internal_default_instance() {
    return reinterpret_cast<const AppendRole*>(
               &_AppendRole_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(AppendRole* other);
  friend void swap(AppendRole& a, AppendRole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendRole* New() const PROTOBUF_FINAL { return New(NULL); }

  AppendRole* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppendRole& from);
  void MergeFrom(const AppendRole& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppendRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // string role_name = 2;
  void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  const ::std::string& role_name() const;
  void set_role_name(const ::std::string& value);
  #if LANG_CXX11
  void set_role_name(::std::string&& value);
  #endif
  void set_role_name(const char* value);
  void set_role_name(const char* value, size_t size);
  ::std::string* mutable_role_name();
  ::std::string* release_role_name();
  void set_allocated_role_name(::std::string* role_name);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AppendRole)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr role_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsAppendRoleImpl();
};
// -------------------------------------------------------------------

class DetachRole : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.DetachRole) */ {
 public:
  DetachRole();
  virtual ~DetachRole();

  DetachRole(const DetachRole& from);

  inline DetachRole& operator=(const DetachRole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetachRole(DetachRole&& from) noexcept
    : DetachRole() {
    *this = ::std::move(from);
  }

  inline DetachRole& operator=(DetachRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DetachRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetachRole* internal_default_instance() {
    return reinterpret_cast<const DetachRole*>(
               &_DetachRole_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DetachRole* other);
  friend void swap(DetachRole& a, DetachRole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetachRole* New() const PROTOBUF_FINAL { return New(NULL); }

  DetachRole* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DetachRole& from);
  void MergeFrom(const DetachRole& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DetachRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // string role_name = 2;
  void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  const ::std::string& role_name() const;
  void set_role_name(const ::std::string& value);
  #if LANG_CXX11
  void set_role_name(::std::string&& value);
  #endif
  void set_role_name(const char* value);
  void set_role_name(const char* value, size_t size);
  ::std::string* mutable_role_name();
  ::std::string* release_role_name();
  void set_allocated_role_name(::std::string* role_name);

  // @@protoc_insertion_point(class_scope:iroha.protocol.DetachRole)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr role_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsDetachRoleImpl();
};
// -------------------------------------------------------------------

class CreateRole : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CreateRole) */ {
 public:
  CreateRole();
  virtual ~CreateRole();

  CreateRole(const CreateRole& from);

  inline CreateRole& operator=(const CreateRole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRole(CreateRole&& from) noexcept
    : CreateRole() {
    *this = ::std::move(from);
  }

  inline CreateRole& operator=(CreateRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRole* internal_default_instance() {
    return reinterpret_cast<const CreateRole*>(
               &_CreateRole_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(CreateRole* other);
  friend void swap(CreateRole& a, CreateRole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRole* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRole* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRole& from);
  void MergeFrom(const CreateRole& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iroha.protocol.RolePermission permissions = 2;
  int permissions_size() const;
  void clear_permissions();
  static const int kPermissionsFieldNumber = 2;
  ::iroha::protocol::RolePermission permissions(int index) const;
  void set_permissions(int index, ::iroha::protocol::RolePermission value);
  void add_permissions(::iroha::protocol::RolePermission value);
  const ::google::protobuf::RepeatedField<int>& permissions() const;
  ::google::protobuf::RepeatedField<int>* mutable_permissions();

  // string role_name = 1;
  void clear_role_name();
  static const int kRoleNameFieldNumber = 1;
  const ::std::string& role_name() const;
  void set_role_name(const ::std::string& value);
  #if LANG_CXX11
  void set_role_name(::std::string&& value);
  #endif
  void set_role_name(const char* value);
  void set_role_name(const char* value, size_t size);
  ::std::string* mutable_role_name();
  ::std::string* release_role_name();
  void set_allocated_role_name(::std::string* role_name);

  // @@protoc_insertion_point(class_scope:iroha.protocol.CreateRole)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> permissions_;
  mutable int _permissions_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr role_name_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsCreateRoleImpl();
};
// -------------------------------------------------------------------

class GrantPermission : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GrantPermission) */ {
 public:
  GrantPermission();
  virtual ~GrantPermission();

  GrantPermission(const GrantPermission& from);

  inline GrantPermission& operator=(const GrantPermission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GrantPermission(GrantPermission&& from) noexcept
    : GrantPermission() {
    *this = ::std::move(from);
  }

  inline GrantPermission& operator=(GrantPermission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GrantPermission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GrantPermission* internal_default_instance() {
    return reinterpret_cast<const GrantPermission*>(
               &_GrantPermission_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(GrantPermission* other);
  friend void swap(GrantPermission& a, GrantPermission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GrantPermission* New() const PROTOBUF_FINAL { return New(NULL); }

  GrantPermission* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GrantPermission& from);
  void MergeFrom(const GrantPermission& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GrantPermission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // .iroha.protocol.GrantablePermission permission = 2;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::iroha::protocol::GrantablePermission permission() const;
  void set_permission(::iroha::protocol::GrantablePermission value);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GrantPermission)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  int permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsGrantPermissionImpl();
};
// -------------------------------------------------------------------

class RevokePermission : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RevokePermission) */ {
 public:
  RevokePermission();
  virtual ~RevokePermission();

  RevokePermission(const RevokePermission& from);

  inline RevokePermission& operator=(const RevokePermission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RevokePermission(RevokePermission&& from) noexcept
    : RevokePermission() {
    *this = ::std::move(from);
  }

  inline RevokePermission& operator=(RevokePermission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RevokePermission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RevokePermission* internal_default_instance() {
    return reinterpret_cast<const RevokePermission*>(
               &_RevokePermission_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(RevokePermission* other);
  friend void swap(RevokePermission& a, RevokePermission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RevokePermission* New() const PROTOBUF_FINAL { return New(NULL); }

  RevokePermission* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RevokePermission& from);
  void MergeFrom(const RevokePermission& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RevokePermission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // .iroha.protocol.GrantablePermission permission = 2;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::iroha::protocol::GrantablePermission permission() const;
  void set_permission(::iroha::protocol::GrantablePermission value);

  // @@protoc_insertion_point(class_scope:iroha.protocol.RevokePermission)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  int permission_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsRevokePermissionImpl();
};
// -------------------------------------------------------------------

class SubtractAssetQuantity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SubtractAssetQuantity) */ {
 public:
  SubtractAssetQuantity();
  virtual ~SubtractAssetQuantity();

  SubtractAssetQuantity(const SubtractAssetQuantity& from);

  inline SubtractAssetQuantity& operator=(const SubtractAssetQuantity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubtractAssetQuantity(SubtractAssetQuantity&& from) noexcept
    : SubtractAssetQuantity() {
    *this = ::std::move(from);
  }

  inline SubtractAssetQuantity& operator=(SubtractAssetQuantity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubtractAssetQuantity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubtractAssetQuantity* internal_default_instance() {
    return reinterpret_cast<const SubtractAssetQuantity*>(
               &_SubtractAssetQuantity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(SubtractAssetQuantity* other);
  friend void swap(SubtractAssetQuantity& a, SubtractAssetQuantity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubtractAssetQuantity* New() const PROTOBUF_FINAL { return New(NULL); }

  SubtractAssetQuantity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubtractAssetQuantity& from);
  void MergeFrom(const SubtractAssetQuantity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubtractAssetQuantity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // string asset_id = 2;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 2;
  const ::std::string& asset_id() const;
  void set_asset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_id(::std::string&& value);
  #endif
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  ::std::string* mutable_asset_id();
  ::std::string* release_asset_id();
  void set_allocated_asset_id(::std::string* asset_id);

  // .iroha.protocol.Amount amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  const ::iroha::protocol::Amount& amount() const;
  ::iroha::protocol::Amount* release_amount();
  ::iroha::protocol::Amount* mutable_amount();
  void set_allocated_amount(::iroha::protocol::Amount* amount);

  // @@protoc_insertion_point(class_scope:iroha.protocol.SubtractAssetQuantity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr asset_id_;
  ::iroha::protocol::Amount* amount_;
  mutable int _cached_size_;
  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsSubtractAssetQuantityImpl();
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  enum CommandCase {
    kAddAssetQuantity = 1,
    kAddPeer = 2,
    kAddSignatory = 3,
    kAppendRole = 4,
    kCreateAccount = 5,
    kCreateAsset = 6,
    kCreateDomain = 7,
    kCreateRole = 8,
    kDetachRole = 9,
    kGrantPermission = 10,
    kRemoveSign = 11,
    kRevokePermission = 12,
    kSetAccountDetail = 13,
    kSetQuorum = 14,
    kSubtractAssetQuantity = 15,
    kTransferAsset = 16,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const PROTOBUF_FINAL { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iroha.protocol.AddAssetQuantity add_asset_quantity = 1;
  bool has_add_asset_quantity() const;
  void clear_add_asset_quantity();
  static const int kAddAssetQuantityFieldNumber = 1;
  const ::iroha::protocol::AddAssetQuantity& add_asset_quantity() const;
  ::iroha::protocol::AddAssetQuantity* release_add_asset_quantity();
  ::iroha::protocol::AddAssetQuantity* mutable_add_asset_quantity();
  void set_allocated_add_asset_quantity(::iroha::protocol::AddAssetQuantity* add_asset_quantity);

  // .iroha.protocol.AddPeer add_peer = 2;
  bool has_add_peer() const;
  void clear_add_peer();
  static const int kAddPeerFieldNumber = 2;
  const ::iroha::protocol::AddPeer& add_peer() const;
  ::iroha::protocol::AddPeer* release_add_peer();
  ::iroha::protocol::AddPeer* mutable_add_peer();
  void set_allocated_add_peer(::iroha::protocol::AddPeer* add_peer);

  // .iroha.protocol.AddSignatory add_signatory = 3;
  bool has_add_signatory() const;
  void clear_add_signatory();
  static const int kAddSignatoryFieldNumber = 3;
  const ::iroha::protocol::AddSignatory& add_signatory() const;
  ::iroha::protocol::AddSignatory* release_add_signatory();
  ::iroha::protocol::AddSignatory* mutable_add_signatory();
  void set_allocated_add_signatory(::iroha::protocol::AddSignatory* add_signatory);

  // .iroha.protocol.AppendRole append_role = 4;
  bool has_append_role() const;
  void clear_append_role();
  static const int kAppendRoleFieldNumber = 4;
  const ::iroha::protocol::AppendRole& append_role() const;
  ::iroha::protocol::AppendRole* release_append_role();
  ::iroha::protocol::AppendRole* mutable_append_role();
  void set_allocated_append_role(::iroha::protocol::AppendRole* append_role);

  // .iroha.protocol.CreateAccount create_account = 5;
  bool has_create_account() const;
  void clear_create_account();
  static const int kCreateAccountFieldNumber = 5;
  const ::iroha::protocol::CreateAccount& create_account() const;
  ::iroha::protocol::CreateAccount* release_create_account();
  ::iroha::protocol::CreateAccount* mutable_create_account();
  void set_allocated_create_account(::iroha::protocol::CreateAccount* create_account);

  // .iroha.protocol.CreateAsset create_asset = 6;
  bool has_create_asset() const;
  void clear_create_asset();
  static const int kCreateAssetFieldNumber = 6;
  const ::iroha::protocol::CreateAsset& create_asset() const;
  ::iroha::protocol::CreateAsset* release_create_asset();
  ::iroha::protocol::CreateAsset* mutable_create_asset();
  void set_allocated_create_asset(::iroha::protocol::CreateAsset* create_asset);

  // .iroha.protocol.CreateDomain create_domain = 7;
  bool has_create_domain() const;
  void clear_create_domain();
  static const int kCreateDomainFieldNumber = 7;
  const ::iroha::protocol::CreateDomain& create_domain() const;
  ::iroha::protocol::CreateDomain* release_create_domain();
  ::iroha::protocol::CreateDomain* mutable_create_domain();
  void set_allocated_create_domain(::iroha::protocol::CreateDomain* create_domain);

  // .iroha.protocol.CreateRole create_role = 8;
  bool has_create_role() const;
  void clear_create_role();
  static const int kCreateRoleFieldNumber = 8;
  const ::iroha::protocol::CreateRole& create_role() const;
  ::iroha::protocol::CreateRole* release_create_role();
  ::iroha::protocol::CreateRole* mutable_create_role();
  void set_allocated_create_role(::iroha::protocol::CreateRole* create_role);

  // .iroha.protocol.DetachRole detach_role = 9;
  bool has_detach_role() const;
  void clear_detach_role();
  static const int kDetachRoleFieldNumber = 9;
  const ::iroha::protocol::DetachRole& detach_role() const;
  ::iroha::protocol::DetachRole* release_detach_role();
  ::iroha::protocol::DetachRole* mutable_detach_role();
  void set_allocated_detach_role(::iroha::protocol::DetachRole* detach_role);

  // .iroha.protocol.GrantPermission grant_permission = 10;
  bool has_grant_permission() const;
  void clear_grant_permission();
  static const int kGrantPermissionFieldNumber = 10;
  const ::iroha::protocol::GrantPermission& grant_permission() const;
  ::iroha::protocol::GrantPermission* release_grant_permission();
  ::iroha::protocol::GrantPermission* mutable_grant_permission();
  void set_allocated_grant_permission(::iroha::protocol::GrantPermission* grant_permission);

  // .iroha.protocol.RemoveSignatory remove_sign = 11;
  bool has_remove_sign() const;
  void clear_remove_sign();
  static const int kRemoveSignFieldNumber = 11;
  const ::iroha::protocol::RemoveSignatory& remove_sign() const;
  ::iroha::protocol::RemoveSignatory* release_remove_sign();
  ::iroha::protocol::RemoveSignatory* mutable_remove_sign();
  void set_allocated_remove_sign(::iroha::protocol::RemoveSignatory* remove_sign);

  // .iroha.protocol.RevokePermission revoke_permission = 12;
  bool has_revoke_permission() const;
  void clear_revoke_permission();
  static const int kRevokePermissionFieldNumber = 12;
  const ::iroha::protocol::RevokePermission& revoke_permission() const;
  ::iroha::protocol::RevokePermission* release_revoke_permission();
  ::iroha::protocol::RevokePermission* mutable_revoke_permission();
  void set_allocated_revoke_permission(::iroha::protocol::RevokePermission* revoke_permission);

  // .iroha.protocol.SetAccountDetail set_account_detail = 13;
  bool has_set_account_detail() const;
  void clear_set_account_detail();
  static const int kSetAccountDetailFieldNumber = 13;
  const ::iroha::protocol::SetAccountDetail& set_account_detail() const;
  ::iroha::protocol::SetAccountDetail* release_set_account_detail();
  ::iroha::protocol::SetAccountDetail* mutable_set_account_detail();
  void set_allocated_set_account_detail(::iroha::protocol::SetAccountDetail* set_account_detail);

  // .iroha.protocol.SetAccountQuorum set_quorum = 14;
  bool has_set_quorum() const;
  void clear_set_quorum();
  static const int kSetQuorumFieldNumber = 14;
  const ::iroha::protocol::SetAccountQuorum& set_quorum() const;
  ::iroha::protocol::SetAccountQuorum* release_set_quorum();
  ::iroha::protocol::SetAccountQuorum* mutable_set_quorum();
  void set_allocated_set_quorum(::iroha::protocol::SetAccountQuorum* set_quorum);

  // .iroha.protocol.SubtractAssetQuantity subtract_asset_quantity = 15;
  bool has_subtract_asset_quantity() const;
  void clear_subtract_asset_quantity();
  static const int kSubtractAssetQuantityFieldNumber = 15;
  const ::iroha::protocol::SubtractAssetQuantity& subtract_asset_quantity() const;
  ::iroha::protocol::SubtractAssetQuantity* release_subtract_asset_quantity();
  ::iroha::protocol::SubtractAssetQuantity* mutable_subtract_asset_quantity();
  void set_allocated_subtract_asset_quantity(::iroha::protocol::SubtractAssetQuantity* subtract_asset_quantity);

  // .iroha.protocol.TransferAsset transfer_asset = 16;
  bool has_transfer_asset() const;
  void clear_transfer_asset();
  static const int kTransferAssetFieldNumber = 16;
  const ::iroha::protocol::TransferAsset& transfer_asset() const;
  ::iroha::protocol::TransferAsset* release_transfer_asset();
  ::iroha::protocol::TransferAsset* mutable_transfer_asset();
  void set_allocated_transfer_asset(::iroha::protocol::TransferAsset* transfer_asset);

  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.Command)
 private:
  void set_has_add_asset_quantity();
  void set_has_add_peer();
  void set_has_add_signatory();
  void set_has_append_role();
  void set_has_create_account();
  void set_has_create_asset();
  void set_has_create_domain();
  void set_has_create_role();
  void set_has_detach_role();
  void set_has_grant_permission();
  void set_has_remove_sign();
  void set_has_revoke_permission();
  void set_has_set_account_detail();
  void set_has_set_quorum();
  void set_has_subtract_asset_quantity();
  void set_has_transfer_asset();

  inline bool has_command() const;
  void clear_command();
  inline void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union CommandUnion {
    CommandUnion() {}
    ::iroha::protocol::AddAssetQuantity* add_asset_quantity_;
    ::iroha::protocol::AddPeer* add_peer_;
    ::iroha::protocol::AddSignatory* add_signatory_;
    ::iroha::protocol::AppendRole* append_role_;
    ::iroha::protocol::CreateAccount* create_account_;
    ::iroha::protocol::CreateAsset* create_asset_;
    ::iroha::protocol::CreateDomain* create_domain_;
    ::iroha::protocol::CreateRole* create_role_;
    ::iroha::protocol::DetachRole* detach_role_;
    ::iroha::protocol::GrantPermission* grant_permission_;
    ::iroha::protocol::RemoveSignatory* remove_sign_;
    ::iroha::protocol::RevokePermission* revoke_permission_;
    ::iroha::protocol::SetAccountDetail* set_account_detail_;
    ::iroha::protocol::SetAccountQuorum* set_quorum_;
    ::iroha::protocol::SubtractAssetQuantity* subtract_asset_quantity_;
    ::iroha::protocol::TransferAsset* transfer_asset_;
  } command_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_commands_2eproto::TableStruct;
  friend void ::protobuf_commands_2eproto::InitDefaultsCommandImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AddAssetQuantity

// string account_id = 1;
inline void AddAssetQuantity::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddAssetQuantity::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddAssetQuantity.account_id)
  return account_id_.GetNoArena();
}
inline void AddAssetQuantity::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AddAssetQuantity.account_id)
}
#if LANG_CXX11
inline void AddAssetQuantity::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AddAssetQuantity.account_id)
}
#endif
inline void AddAssetQuantity::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AddAssetQuantity.account_id)
}
inline void AddAssetQuantity::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AddAssetQuantity.account_id)
}
inline ::std::string* AddAssetQuantity::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddAssetQuantity.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddAssetQuantity::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddAssetQuantity.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddAssetQuantity::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddAssetQuantity.account_id)
}

// string asset_id = 2;
inline void AddAssetQuantity::clear_asset_id() {
  asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddAssetQuantity::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddAssetQuantity.asset_id)
  return asset_id_.GetNoArena();
}
inline void AddAssetQuantity::set_asset_id(const ::std::string& value) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AddAssetQuantity.asset_id)
}
#if LANG_CXX11
inline void AddAssetQuantity::set_asset_id(::std::string&& value) {
  
  asset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AddAssetQuantity.asset_id)
}
#endif
inline void AddAssetQuantity::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AddAssetQuantity.asset_id)
}
inline void AddAssetQuantity::set_asset_id(const char* value, size_t size) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AddAssetQuantity.asset_id)
}
inline ::std::string* AddAssetQuantity::mutable_asset_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddAssetQuantity.asset_id)
  return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddAssetQuantity::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddAssetQuantity.asset_id)
  
  return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddAssetQuantity::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id != NULL) {
    
  } else {
    
  }
  asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddAssetQuantity.asset_id)
}

// .iroha.protocol.Amount amount = 3;
inline bool AddAssetQuantity::has_amount() const {
  return this != internal_default_instance() && amount_ != NULL;
}
inline const ::iroha::protocol::Amount& AddAssetQuantity::amount() const {
  const ::iroha::protocol::Amount* p = amount_;
  // @@protoc_insertion_point(field_get:iroha.protocol.AddAssetQuantity.amount)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Amount*>(
      &::iroha::protocol::_Amount_default_instance_);
}
inline ::iroha::protocol::Amount* AddAssetQuantity::release_amount() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddAssetQuantity.amount)
  
  ::iroha::protocol::Amount* temp = amount_;
  amount_ = NULL;
  return temp;
}
inline ::iroha::protocol::Amount* AddAssetQuantity::mutable_amount() {
  
  if (amount_ == NULL) {
    amount_ = new ::iroha::protocol::Amount;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddAssetQuantity.amount)
  return amount_;
}
inline void AddAssetQuantity::set_allocated_amount(::iroha::protocol::Amount* amount) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(amount_);
  }
  if (amount) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      amount = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddAssetQuantity.amount)
}

// -------------------------------------------------------------------

// AddPeer

// .iroha.protocol.Peer peer = 1;
inline bool AddPeer::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::iroha::protocol::Peer& AddPeer::peer() const {
  const ::iroha::protocol::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:iroha.protocol.AddPeer.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Peer*>(
      &::iroha::protocol::_Peer_default_instance_);
}
inline ::iroha::protocol::Peer* AddPeer::release_peer() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddPeer.peer)
  
  ::iroha::protocol::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::iroha::protocol::Peer* AddPeer::mutable_peer() {
  
  if (peer_ == NULL) {
    peer_ = new ::iroha::protocol::Peer;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddPeer.peer)
  return peer_;
}
inline void AddPeer::set_allocated_peer(::iroha::protocol::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddPeer.peer)
}

// -------------------------------------------------------------------

// AddSignatory

// string account_id = 1;
inline void AddSignatory::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddSignatory::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddSignatory.account_id)
  return account_id_.GetNoArena();
}
inline void AddSignatory::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AddSignatory.account_id)
}
#if LANG_CXX11
inline void AddSignatory::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AddSignatory.account_id)
}
#endif
inline void AddSignatory::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AddSignatory.account_id)
}
inline void AddSignatory::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AddSignatory.account_id)
}
inline ::std::string* AddSignatory::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddSignatory.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddSignatory::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddSignatory.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddSignatory::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddSignatory.account_id)
}

// bytes public_key = 2;
inline void AddSignatory::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddSignatory::public_key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddSignatory.public_key)
  return public_key_.GetNoArena();
}
inline void AddSignatory::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AddSignatory.public_key)
}
#if LANG_CXX11
inline void AddSignatory::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AddSignatory.public_key)
}
#endif
inline void AddSignatory::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AddSignatory.public_key)
}
inline void AddSignatory::set_public_key(const void* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AddSignatory.public_key)
}
inline ::std::string* AddSignatory::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddSignatory.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddSignatory::release_public_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddSignatory.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddSignatory::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddSignatory.public_key)
}

// -------------------------------------------------------------------

// CreateAsset

// string asset_name = 1;
inline void CreateAsset::clear_asset_name() {
  asset_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateAsset::asset_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAsset.asset_name)
  return asset_name_.GetNoArena();
}
inline void CreateAsset::set_asset_name(const ::std::string& value) {
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAsset.asset_name)
}
#if LANG_CXX11
inline void CreateAsset::set_asset_name(::std::string&& value) {
  
  asset_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.CreateAsset.asset_name)
}
#endif
inline void CreateAsset::set_asset_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.CreateAsset.asset_name)
}
inline void CreateAsset::set_asset_name(const char* value, size_t size) {
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.CreateAsset.asset_name)
}
inline ::std::string* CreateAsset::mutable_asset_name() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAsset.asset_name)
  return asset_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAsset::release_asset_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAsset.asset_name)
  
  return asset_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAsset::set_allocated_asset_name(::std::string* asset_name) {
  if (asset_name != NULL) {
    
  } else {
    
  }
  asset_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_name);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAsset.asset_name)
}

// string domain_id = 2;
inline void CreateAsset::clear_domain_id() {
  domain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateAsset::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAsset.domain_id)
  return domain_id_.GetNoArena();
}
inline void CreateAsset::set_domain_id(const ::std::string& value) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAsset.domain_id)
}
#if LANG_CXX11
inline void CreateAsset::set_domain_id(::std::string&& value) {
  
  domain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.CreateAsset.domain_id)
}
#endif
inline void CreateAsset::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.CreateAsset.domain_id)
}
inline void CreateAsset::set_domain_id(const char* value, size_t size) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.CreateAsset.domain_id)
}
inline ::std::string* CreateAsset::mutable_domain_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAsset.domain_id)
  return domain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAsset::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAsset.domain_id)
  
  return domain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAsset::set_allocated_domain_id(::std::string* domain_id) {
  if (domain_id != NULL) {
    
  } else {
    
  }
  domain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAsset.domain_id)
}

// uint32 precision = 3;
inline void CreateAsset::clear_precision() {
  precision_ = 0u;
}
inline ::google::protobuf::uint32 CreateAsset::precision() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAsset.precision)
  return precision_;
}
inline void CreateAsset::set_precision(::google::protobuf::uint32 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAsset.precision)
}

// -------------------------------------------------------------------

// CreateAccount

// string account_name = 1;
inline void CreateAccount::clear_account_name() {
  account_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateAccount::account_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAccount.account_name)
  return account_name_.GetNoArena();
}
inline void CreateAccount::set_account_name(const ::std::string& value) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAccount.account_name)
}
#if LANG_CXX11
inline void CreateAccount::set_account_name(::std::string&& value) {
  
  account_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.CreateAccount.account_name)
}
#endif
inline void CreateAccount::set_account_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.CreateAccount.account_name)
}
inline void CreateAccount::set_account_name(const char* value, size_t size) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.CreateAccount.account_name)
}
inline ::std::string* CreateAccount::mutable_account_name() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAccount.account_name)
  return account_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAccount::release_account_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAccount.account_name)
  
  return account_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccount::set_allocated_account_name(::std::string* account_name) {
  if (account_name != NULL) {
    
  } else {
    
  }
  account_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_name);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAccount.account_name)
}

// string domain_id = 2;
inline void CreateAccount::clear_domain_id() {
  domain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateAccount::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAccount.domain_id)
  return domain_id_.GetNoArena();
}
inline void CreateAccount::set_domain_id(const ::std::string& value) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAccount.domain_id)
}
#if LANG_CXX11
inline void CreateAccount::set_domain_id(::std::string&& value) {
  
  domain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.CreateAccount.domain_id)
}
#endif
inline void CreateAccount::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.CreateAccount.domain_id)
}
inline void CreateAccount::set_domain_id(const char* value, size_t size) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.CreateAccount.domain_id)
}
inline ::std::string* CreateAccount::mutable_domain_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAccount.domain_id)
  return domain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAccount::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAccount.domain_id)
  
  return domain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccount::set_allocated_domain_id(::std::string* domain_id) {
  if (domain_id != NULL) {
    
  } else {
    
  }
  domain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAccount.domain_id)
}

// bytes main_pubkey = 3;
inline void CreateAccount::clear_main_pubkey() {
  main_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateAccount::main_pubkey() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAccount.main_pubkey)
  return main_pubkey_.GetNoArena();
}
inline void CreateAccount::set_main_pubkey(const ::std::string& value) {
  
  main_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAccount.main_pubkey)
}
#if LANG_CXX11
inline void CreateAccount::set_main_pubkey(::std::string&& value) {
  
  main_pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.CreateAccount.main_pubkey)
}
#endif
inline void CreateAccount::set_main_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  main_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.CreateAccount.main_pubkey)
}
inline void CreateAccount::set_main_pubkey(const void* value, size_t size) {
  
  main_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.CreateAccount.main_pubkey)
}
inline ::std::string* CreateAccount::mutable_main_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAccount.main_pubkey)
  return main_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAccount::release_main_pubkey() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAccount.main_pubkey)
  
  return main_pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccount::set_allocated_main_pubkey(::std::string* main_pubkey) {
  if (main_pubkey != NULL) {
    
  } else {
    
  }
  main_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), main_pubkey);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAccount.main_pubkey)
}

// -------------------------------------------------------------------

// SetAccountDetail

// string account_id = 1;
inline void SetAccountDetail::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetAccountDetail::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountDetail.account_id)
  return account_id_.GetNoArena();
}
inline void SetAccountDetail::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountDetail.account_id)
}
#if LANG_CXX11
inline void SetAccountDetail::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.SetAccountDetail.account_id)
}
#endif
inline void SetAccountDetail::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.SetAccountDetail.account_id)
}
inline void SetAccountDetail::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.SetAccountDetail.account_id)
}
inline ::std::string* SetAccountDetail::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetAccountDetail.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetAccountDetail::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetAccountDetail.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetAccountDetail::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetAccountDetail.account_id)
}

// string key = 2;
inline void SetAccountDetail::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetAccountDetail::key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountDetail.key)
  return key_.GetNoArena();
}
inline void SetAccountDetail::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountDetail.key)
}
#if LANG_CXX11
inline void SetAccountDetail::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.SetAccountDetail.key)
}
#endif
inline void SetAccountDetail::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.SetAccountDetail.key)
}
inline void SetAccountDetail::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.SetAccountDetail.key)
}
inline ::std::string* SetAccountDetail::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetAccountDetail.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetAccountDetail::release_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetAccountDetail.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetAccountDetail::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetAccountDetail.key)
}

// string value = 3;
inline void SetAccountDetail::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetAccountDetail::value() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountDetail.value)
  return value_.GetNoArena();
}
inline void SetAccountDetail::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountDetail.value)
}
#if LANG_CXX11
inline void SetAccountDetail::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.SetAccountDetail.value)
}
#endif
inline void SetAccountDetail::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.SetAccountDetail.value)
}
inline void SetAccountDetail::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.SetAccountDetail.value)
}
inline ::std::string* SetAccountDetail::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetAccountDetail.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetAccountDetail::release_value() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetAccountDetail.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetAccountDetail::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetAccountDetail.value)
}

// -------------------------------------------------------------------

// CreateDomain

// string domain_id = 1;
inline void CreateDomain::clear_domain_id() {
  domain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateDomain::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateDomain.domain_id)
  return domain_id_.GetNoArena();
}
inline void CreateDomain::set_domain_id(const ::std::string& value) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateDomain.domain_id)
}
#if LANG_CXX11
inline void CreateDomain::set_domain_id(::std::string&& value) {
  
  domain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.CreateDomain.domain_id)
}
#endif
inline void CreateDomain::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.CreateDomain.domain_id)
}
inline void CreateDomain::set_domain_id(const char* value, size_t size) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.CreateDomain.domain_id)
}
inline ::std::string* CreateDomain::mutable_domain_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateDomain.domain_id)
  return domain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateDomain::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateDomain.domain_id)
  
  return domain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateDomain::set_allocated_domain_id(::std::string* domain_id) {
  if (domain_id != NULL) {
    
  } else {
    
  }
  domain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateDomain.domain_id)
}

// string default_role = 2;
inline void CreateDomain::clear_default_role() {
  default_role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateDomain::default_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateDomain.default_role)
  return default_role_.GetNoArena();
}
inline void CreateDomain::set_default_role(const ::std::string& value) {
  
  default_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateDomain.default_role)
}
#if LANG_CXX11
inline void CreateDomain::set_default_role(::std::string&& value) {
  
  default_role_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.CreateDomain.default_role)
}
#endif
inline void CreateDomain::set_default_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  default_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.CreateDomain.default_role)
}
inline void CreateDomain::set_default_role(const char* value, size_t size) {
  
  default_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.CreateDomain.default_role)
}
inline ::std::string* CreateDomain::mutable_default_role() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateDomain.default_role)
  return default_role_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateDomain::release_default_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateDomain.default_role)
  
  return default_role_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateDomain::set_allocated_default_role(::std::string* default_role) {
  if (default_role != NULL) {
    
  } else {
    
  }
  default_role_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_role);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateDomain.default_role)
}

// -------------------------------------------------------------------

// RemoveSignatory

// string account_id = 1;
inline void RemoveSignatory::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RemoveSignatory::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RemoveSignatory.account_id)
  return account_id_.GetNoArena();
}
inline void RemoveSignatory::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.RemoveSignatory.account_id)
}
#if LANG_CXX11
inline void RemoveSignatory::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.RemoveSignatory.account_id)
}
#endif
inline void RemoveSignatory::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.RemoveSignatory.account_id)
}
inline void RemoveSignatory::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.RemoveSignatory.account_id)
}
inline ::std::string* RemoveSignatory::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RemoveSignatory.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemoveSignatory::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.RemoveSignatory.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoveSignatory::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.RemoveSignatory.account_id)
}

// bytes public_key = 2;
inline void RemoveSignatory::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RemoveSignatory::public_key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RemoveSignatory.public_key)
  return public_key_.GetNoArena();
}
inline void RemoveSignatory::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.RemoveSignatory.public_key)
}
#if LANG_CXX11
inline void RemoveSignatory::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.RemoveSignatory.public_key)
}
#endif
inline void RemoveSignatory::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.RemoveSignatory.public_key)
}
inline void RemoveSignatory::set_public_key(const void* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.RemoveSignatory.public_key)
}
inline ::std::string* RemoveSignatory::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RemoveSignatory.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemoveSignatory::release_public_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.RemoveSignatory.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemoveSignatory::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.RemoveSignatory.public_key)
}

// -------------------------------------------------------------------

// SetAccountQuorum

// string account_id = 1;
inline void SetAccountQuorum::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetAccountQuorum::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountQuorum.account_id)
  return account_id_.GetNoArena();
}
inline void SetAccountQuorum::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountQuorum.account_id)
}
#if LANG_CXX11
inline void SetAccountQuorum::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.SetAccountQuorum.account_id)
}
#endif
inline void SetAccountQuorum::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.SetAccountQuorum.account_id)
}
inline void SetAccountQuorum::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.SetAccountQuorum.account_id)
}
inline ::std::string* SetAccountQuorum::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetAccountQuorum.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetAccountQuorum::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetAccountQuorum.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetAccountQuorum::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetAccountQuorum.account_id)
}

// uint32 quorum = 2;
inline void SetAccountQuorum::clear_quorum() {
  quorum_ = 0u;
}
inline ::google::protobuf::uint32 SetAccountQuorum::quorum() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountQuorum.quorum)
  return quorum_;
}
inline void SetAccountQuorum::set_quorum(::google::protobuf::uint32 value) {
  
  quorum_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountQuorum.quorum)
}

// -------------------------------------------------------------------

// TransferAsset

// string src_account_id = 1;
inline void TransferAsset::clear_src_account_id() {
  src_account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAsset::src_account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.src_account_id)
  return src_account_id_.GetNoArena();
}
inline void TransferAsset::set_src_account_id(const ::std::string& value) {
  
  src_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.src_account_id)
}
#if LANG_CXX11
inline void TransferAsset::set_src_account_id(::std::string&& value) {
  
  src_account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.TransferAsset.src_account_id)
}
#endif
inline void TransferAsset::set_src_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  src_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.TransferAsset.src_account_id)
}
inline void TransferAsset::set_src_account_id(const char* value, size_t size) {
  
  src_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.TransferAsset.src_account_id)
}
inline ::std::string* TransferAsset::mutable_src_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.src_account_id)
  return src_account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAsset::release_src_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.src_account_id)
  
  return src_account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAsset::set_allocated_src_account_id(::std::string* src_account_id) {
  if (src_account_id != NULL) {
    
  } else {
    
  }
  src_account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.src_account_id)
}

// string dest_account_id = 2;
inline void TransferAsset::clear_dest_account_id() {
  dest_account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAsset::dest_account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.dest_account_id)
  return dest_account_id_.GetNoArena();
}
inline void TransferAsset::set_dest_account_id(const ::std::string& value) {
  
  dest_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.dest_account_id)
}
#if LANG_CXX11
inline void TransferAsset::set_dest_account_id(::std::string&& value) {
  
  dest_account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.TransferAsset.dest_account_id)
}
#endif
inline void TransferAsset::set_dest_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dest_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.TransferAsset.dest_account_id)
}
inline void TransferAsset::set_dest_account_id(const char* value, size_t size) {
  
  dest_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.TransferAsset.dest_account_id)
}
inline ::std::string* TransferAsset::mutable_dest_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.dest_account_id)
  return dest_account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAsset::release_dest_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.dest_account_id)
  
  return dest_account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAsset::set_allocated_dest_account_id(::std::string* dest_account_id) {
  if (dest_account_id != NULL) {
    
  } else {
    
  }
  dest_account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.dest_account_id)
}

// string asset_id = 3;
inline void TransferAsset::clear_asset_id() {
  asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAsset::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.asset_id)
  return asset_id_.GetNoArena();
}
inline void TransferAsset::set_asset_id(const ::std::string& value) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.asset_id)
}
#if LANG_CXX11
inline void TransferAsset::set_asset_id(::std::string&& value) {
  
  asset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.TransferAsset.asset_id)
}
#endif
inline void TransferAsset::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.TransferAsset.asset_id)
}
inline void TransferAsset::set_asset_id(const char* value, size_t size) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.TransferAsset.asset_id)
}
inline ::std::string* TransferAsset::mutable_asset_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.asset_id)
  return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAsset::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.asset_id)
  
  return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAsset::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id != NULL) {
    
  } else {
    
  }
  asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.asset_id)
}

// string description = 4;
inline void TransferAsset::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAsset::description() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.description)
  return description_.GetNoArena();
}
inline void TransferAsset::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.description)
}
#if LANG_CXX11
inline void TransferAsset::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.TransferAsset.description)
}
#endif
inline void TransferAsset::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.TransferAsset.description)
}
inline void TransferAsset::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.TransferAsset.description)
}
inline ::std::string* TransferAsset::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAsset::release_description() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAsset::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.description)
}

// .iroha.protocol.Amount amount = 5;
inline bool TransferAsset::has_amount() const {
  return this != internal_default_instance() && amount_ != NULL;
}
inline const ::iroha::protocol::Amount& TransferAsset::amount() const {
  const ::iroha::protocol::Amount* p = amount_;
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.amount)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Amount*>(
      &::iroha::protocol::_Amount_default_instance_);
}
inline ::iroha::protocol::Amount* TransferAsset::release_amount() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.amount)
  
  ::iroha::protocol::Amount* temp = amount_;
  amount_ = NULL;
  return temp;
}
inline ::iroha::protocol::Amount* TransferAsset::mutable_amount() {
  
  if (amount_ == NULL) {
    amount_ = new ::iroha::protocol::Amount;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.amount)
  return amount_;
}
inline void TransferAsset::set_allocated_amount(::iroha::protocol::Amount* amount) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(amount_);
  }
  if (amount) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      amount = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.amount)
}

// -------------------------------------------------------------------

// AppendRole

// string account_id = 1;
inline void AppendRole::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AppendRole::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AppendRole.account_id)
  return account_id_.GetNoArena();
}
inline void AppendRole::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AppendRole.account_id)
}
#if LANG_CXX11
inline void AppendRole::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AppendRole.account_id)
}
#endif
inline void AppendRole::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AppendRole.account_id)
}
inline void AppendRole::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AppendRole.account_id)
}
inline ::std::string* AppendRole::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AppendRole.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppendRole::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AppendRole.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppendRole::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AppendRole.account_id)
}

// string role_name = 2;
inline void AppendRole::clear_role_name() {
  role_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AppendRole::role_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AppendRole.role_name)
  return role_name_.GetNoArena();
}
inline void AppendRole::set_role_name(const ::std::string& value) {
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AppendRole.role_name)
}
#if LANG_CXX11
inline void AppendRole::set_role_name(::std::string&& value) {
  
  role_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AppendRole.role_name)
}
#endif
inline void AppendRole::set_role_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AppendRole.role_name)
}
inline void AppendRole::set_role_name(const char* value, size_t size) {
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AppendRole.role_name)
}
inline ::std::string* AppendRole::mutable_role_name() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AppendRole.role_name)
  return role_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppendRole::release_role_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AppendRole.role_name)
  
  return role_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppendRole::set_allocated_role_name(::std::string* role_name) {
  if (role_name != NULL) {
    
  } else {
    
  }
  role_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role_name);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AppendRole.role_name)
}

// -------------------------------------------------------------------

// DetachRole

// string account_id = 1;
inline void DetachRole::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DetachRole::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.DetachRole.account_id)
  return account_id_.GetNoArena();
}
inline void DetachRole::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.DetachRole.account_id)
}
#if LANG_CXX11
inline void DetachRole::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.DetachRole.account_id)
}
#endif
inline void DetachRole::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.DetachRole.account_id)
}
inline void DetachRole::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.DetachRole.account_id)
}
inline ::std::string* DetachRole::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.DetachRole.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DetachRole::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.DetachRole.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetachRole::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.DetachRole.account_id)
}

// string role_name = 2;
inline void DetachRole::clear_role_name() {
  role_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DetachRole::role_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.DetachRole.role_name)
  return role_name_.GetNoArena();
}
inline void DetachRole::set_role_name(const ::std::string& value) {
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.DetachRole.role_name)
}
#if LANG_CXX11
inline void DetachRole::set_role_name(::std::string&& value) {
  
  role_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.DetachRole.role_name)
}
#endif
inline void DetachRole::set_role_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.DetachRole.role_name)
}
inline void DetachRole::set_role_name(const char* value, size_t size) {
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.DetachRole.role_name)
}
inline ::std::string* DetachRole::mutable_role_name() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.DetachRole.role_name)
  return role_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DetachRole::release_role_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.DetachRole.role_name)
  
  return role_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetachRole::set_allocated_role_name(::std::string* role_name) {
  if (role_name != NULL) {
    
  } else {
    
  }
  role_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role_name);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.DetachRole.role_name)
}

// -------------------------------------------------------------------

// CreateRole

// string role_name = 1;
inline void CreateRole::clear_role_name() {
  role_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRole::role_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateRole.role_name)
  return role_name_.GetNoArena();
}
inline void CreateRole::set_role_name(const ::std::string& value) {
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateRole.role_name)
}
#if LANG_CXX11
inline void CreateRole::set_role_name(::std::string&& value) {
  
  role_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.CreateRole.role_name)
}
#endif
inline void CreateRole::set_role_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.CreateRole.role_name)
}
inline void CreateRole::set_role_name(const char* value, size_t size) {
  
  role_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.CreateRole.role_name)
}
inline ::std::string* CreateRole::mutable_role_name() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateRole.role_name)
  return role_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRole::release_role_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateRole.role_name)
  
  return role_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRole::set_allocated_role_name(::std::string* role_name) {
  if (role_name != NULL) {
    
  } else {
    
  }
  role_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role_name);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateRole.role_name)
}

// repeated .iroha.protocol.RolePermission permissions = 2;
inline int CreateRole::permissions_size() const {
  return permissions_.size();
}
inline void CreateRole::clear_permissions() {
  permissions_.Clear();
}
inline ::iroha::protocol::RolePermission CreateRole::permissions(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateRole.permissions)
  return static_cast< ::iroha::protocol::RolePermission >(permissions_.Get(index));
}
inline void CreateRole::set_permissions(int index, ::iroha::protocol::RolePermission value) {
  permissions_.Set(index, value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateRole.permissions)
}
inline void CreateRole::add_permissions(::iroha::protocol::RolePermission value) {
  permissions_.Add(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.CreateRole.permissions)
}
inline const ::google::protobuf::RepeatedField<int>&
CreateRole::permissions() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.CreateRole.permissions)
  return permissions_;
}
inline ::google::protobuf::RepeatedField<int>*
CreateRole::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.CreateRole.permissions)
  return &permissions_;
}

// -------------------------------------------------------------------

// GrantPermission

// string account_id = 1;
inline void GrantPermission::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GrantPermission::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GrantPermission.account_id)
  return account_id_.GetNoArena();
}
inline void GrantPermission::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GrantPermission.account_id)
}
#if LANG_CXX11
inline void GrantPermission::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GrantPermission.account_id)
}
#endif
inline void GrantPermission::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GrantPermission.account_id)
}
inline void GrantPermission::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GrantPermission.account_id)
}
inline ::std::string* GrantPermission::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GrantPermission.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GrantPermission::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GrantPermission.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GrantPermission::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GrantPermission.account_id)
}

// .iroha.protocol.GrantablePermission permission = 2;
inline void GrantPermission::clear_permission() {
  permission_ = 0;
}
inline ::iroha::protocol::GrantablePermission GrantPermission::permission() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GrantPermission.permission)
  return static_cast< ::iroha::protocol::GrantablePermission >(permission_);
}
inline void GrantPermission::set_permission(::iroha::protocol::GrantablePermission value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.GrantPermission.permission)
}

// -------------------------------------------------------------------

// RevokePermission

// string account_id = 1;
inline void RevokePermission::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RevokePermission::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RevokePermission.account_id)
  return account_id_.GetNoArena();
}
inline void RevokePermission::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.RevokePermission.account_id)
}
#if LANG_CXX11
inline void RevokePermission::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.RevokePermission.account_id)
}
#endif
inline void RevokePermission::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.RevokePermission.account_id)
}
inline void RevokePermission::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.RevokePermission.account_id)
}
inline ::std::string* RevokePermission::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RevokePermission.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RevokePermission::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.RevokePermission.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RevokePermission::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.RevokePermission.account_id)
}

// .iroha.protocol.GrantablePermission permission = 2;
inline void RevokePermission::clear_permission() {
  permission_ = 0;
}
inline ::iroha::protocol::GrantablePermission RevokePermission::permission() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RevokePermission.permission)
  return static_cast< ::iroha::protocol::GrantablePermission >(permission_);
}
inline void RevokePermission::set_permission(::iroha::protocol::GrantablePermission value) {
  
  permission_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.RevokePermission.permission)
}

// -------------------------------------------------------------------

// SubtractAssetQuantity

// string account_id = 1;
inline void SubtractAssetQuantity::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubtractAssetQuantity::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SubtractAssetQuantity.account_id)
  return account_id_.GetNoArena();
}
inline void SubtractAssetQuantity::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.SubtractAssetQuantity.account_id)
}
#if LANG_CXX11
inline void SubtractAssetQuantity::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.SubtractAssetQuantity.account_id)
}
#endif
inline void SubtractAssetQuantity::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.SubtractAssetQuantity.account_id)
}
inline void SubtractAssetQuantity::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.SubtractAssetQuantity.account_id)
}
inline ::std::string* SubtractAssetQuantity::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SubtractAssetQuantity.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubtractAssetQuantity::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SubtractAssetQuantity.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubtractAssetQuantity::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SubtractAssetQuantity.account_id)
}

// string asset_id = 2;
inline void SubtractAssetQuantity::clear_asset_id() {
  asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubtractAssetQuantity::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SubtractAssetQuantity.asset_id)
  return asset_id_.GetNoArena();
}
inline void SubtractAssetQuantity::set_asset_id(const ::std::string& value) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.SubtractAssetQuantity.asset_id)
}
#if LANG_CXX11
inline void SubtractAssetQuantity::set_asset_id(::std::string&& value) {
  
  asset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.SubtractAssetQuantity.asset_id)
}
#endif
inline void SubtractAssetQuantity::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.SubtractAssetQuantity.asset_id)
}
inline void SubtractAssetQuantity::set_asset_id(const char* value, size_t size) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.SubtractAssetQuantity.asset_id)
}
inline ::std::string* SubtractAssetQuantity::mutable_asset_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SubtractAssetQuantity.asset_id)
  return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubtractAssetQuantity::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SubtractAssetQuantity.asset_id)
  
  return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubtractAssetQuantity::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id != NULL) {
    
  } else {
    
  }
  asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SubtractAssetQuantity.asset_id)
}

// .iroha.protocol.Amount amount = 3;
inline bool SubtractAssetQuantity::has_amount() const {
  return this != internal_default_instance() && amount_ != NULL;
}
inline const ::iroha::protocol::Amount& SubtractAssetQuantity::amount() const {
  const ::iroha::protocol::Amount* p = amount_;
  // @@protoc_insertion_point(field_get:iroha.protocol.SubtractAssetQuantity.amount)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Amount*>(
      &::iroha::protocol::_Amount_default_instance_);
}
inline ::iroha::protocol::Amount* SubtractAssetQuantity::release_amount() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SubtractAssetQuantity.amount)
  
  ::iroha::protocol::Amount* temp = amount_;
  amount_ = NULL;
  return temp;
}
inline ::iroha::protocol::Amount* SubtractAssetQuantity::mutable_amount() {
  
  if (amount_ == NULL) {
    amount_ = new ::iroha::protocol::Amount;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SubtractAssetQuantity.amount)
  return amount_;
}
inline void SubtractAssetQuantity::set_allocated_amount(::iroha::protocol::Amount* amount) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(amount_);
  }
  if (amount) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      amount = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SubtractAssetQuantity.amount)
}

// -------------------------------------------------------------------

// Command

// .iroha.protocol.AddAssetQuantity add_asset_quantity = 1;
inline bool Command::has_add_asset_quantity() const {
  return command_case() == kAddAssetQuantity;
}
inline void Command::set_has_add_asset_quantity() {
  _oneof_case_[0] = kAddAssetQuantity;
}
inline void Command::clear_add_asset_quantity() {
  if (has_add_asset_quantity()) {
    delete command_.add_asset_quantity_;
    clear_has_command();
  }
}
inline ::iroha::protocol::AddAssetQuantity* Command::release_add_asset_quantity() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.add_asset_quantity)
  if (has_add_asset_quantity()) {
    clear_has_command();
      ::iroha::protocol::AddAssetQuantity* temp = command_.add_asset_quantity_;
    command_.add_asset_quantity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::AddAssetQuantity& Command::add_asset_quantity() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.add_asset_quantity)
  return has_add_asset_quantity()
      ? *command_.add_asset_quantity_
      : *reinterpret_cast< ::iroha::protocol::AddAssetQuantity*>(&::iroha::protocol::_AddAssetQuantity_default_instance_);
}
inline ::iroha::protocol::AddAssetQuantity* Command::mutable_add_asset_quantity() {
  if (!has_add_asset_quantity()) {
    clear_command();
    set_has_add_asset_quantity();
    command_.add_asset_quantity_ = new ::iroha::protocol::AddAssetQuantity;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.add_asset_quantity)
  return command_.add_asset_quantity_;
}

// .iroha.protocol.AddPeer add_peer = 2;
inline bool Command::has_add_peer() const {
  return command_case() == kAddPeer;
}
inline void Command::set_has_add_peer() {
  _oneof_case_[0] = kAddPeer;
}
inline void Command::clear_add_peer() {
  if (has_add_peer()) {
    delete command_.add_peer_;
    clear_has_command();
  }
}
inline ::iroha::protocol::AddPeer* Command::release_add_peer() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.add_peer)
  if (has_add_peer()) {
    clear_has_command();
      ::iroha::protocol::AddPeer* temp = command_.add_peer_;
    command_.add_peer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::AddPeer& Command::add_peer() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.add_peer)
  return has_add_peer()
      ? *command_.add_peer_
      : *reinterpret_cast< ::iroha::protocol::AddPeer*>(&::iroha::protocol::_AddPeer_default_instance_);
}
inline ::iroha::protocol::AddPeer* Command::mutable_add_peer() {
  if (!has_add_peer()) {
    clear_command();
    set_has_add_peer();
    command_.add_peer_ = new ::iroha::protocol::AddPeer;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.add_peer)
  return command_.add_peer_;
}

// .iroha.protocol.AddSignatory add_signatory = 3;
inline bool Command::has_add_signatory() const {
  return command_case() == kAddSignatory;
}
inline void Command::set_has_add_signatory() {
  _oneof_case_[0] = kAddSignatory;
}
inline void Command::clear_add_signatory() {
  if (has_add_signatory()) {
    delete command_.add_signatory_;
    clear_has_command();
  }
}
inline ::iroha::protocol::AddSignatory* Command::release_add_signatory() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.add_signatory)
  if (has_add_signatory()) {
    clear_has_command();
      ::iroha::protocol::AddSignatory* temp = command_.add_signatory_;
    command_.add_signatory_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::AddSignatory& Command::add_signatory() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.add_signatory)
  return has_add_signatory()
      ? *command_.add_signatory_
      : *reinterpret_cast< ::iroha::protocol::AddSignatory*>(&::iroha::protocol::_AddSignatory_default_instance_);
}
inline ::iroha::protocol::AddSignatory* Command::mutable_add_signatory() {
  if (!has_add_signatory()) {
    clear_command();
    set_has_add_signatory();
    command_.add_signatory_ = new ::iroha::protocol::AddSignatory;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.add_signatory)
  return command_.add_signatory_;
}

// .iroha.protocol.AppendRole append_role = 4;
inline bool Command::has_append_role() const {
  return command_case() == kAppendRole;
}
inline void Command::set_has_append_role() {
  _oneof_case_[0] = kAppendRole;
}
inline void Command::clear_append_role() {
  if (has_append_role()) {
    delete command_.append_role_;
    clear_has_command();
  }
}
inline ::iroha::protocol::AppendRole* Command::release_append_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.append_role)
  if (has_append_role()) {
    clear_has_command();
      ::iroha::protocol::AppendRole* temp = command_.append_role_;
    command_.append_role_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::AppendRole& Command::append_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.append_role)
  return has_append_role()
      ? *command_.append_role_
      : *reinterpret_cast< ::iroha::protocol::AppendRole*>(&::iroha::protocol::_AppendRole_default_instance_);
}
inline ::iroha::protocol::AppendRole* Command::mutable_append_role() {
  if (!has_append_role()) {
    clear_command();
    set_has_append_role();
    command_.append_role_ = new ::iroha::protocol::AppendRole;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.append_role)
  return command_.append_role_;
}

// .iroha.protocol.CreateAccount create_account = 5;
inline bool Command::has_create_account() const {
  return command_case() == kCreateAccount;
}
inline void Command::set_has_create_account() {
  _oneof_case_[0] = kCreateAccount;
}
inline void Command::clear_create_account() {
  if (has_create_account()) {
    delete command_.create_account_;
    clear_has_command();
  }
}
inline ::iroha::protocol::CreateAccount* Command::release_create_account() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.create_account)
  if (has_create_account()) {
    clear_has_command();
      ::iroha::protocol::CreateAccount* temp = command_.create_account_;
    command_.create_account_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::CreateAccount& Command::create_account() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.create_account)
  return has_create_account()
      ? *command_.create_account_
      : *reinterpret_cast< ::iroha::protocol::CreateAccount*>(&::iroha::protocol::_CreateAccount_default_instance_);
}
inline ::iroha::protocol::CreateAccount* Command::mutable_create_account() {
  if (!has_create_account()) {
    clear_command();
    set_has_create_account();
    command_.create_account_ = new ::iroha::protocol::CreateAccount;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.create_account)
  return command_.create_account_;
}

// .iroha.protocol.CreateAsset create_asset = 6;
inline bool Command::has_create_asset() const {
  return command_case() == kCreateAsset;
}
inline void Command::set_has_create_asset() {
  _oneof_case_[0] = kCreateAsset;
}
inline void Command::clear_create_asset() {
  if (has_create_asset()) {
    delete command_.create_asset_;
    clear_has_command();
  }
}
inline ::iroha::protocol::CreateAsset* Command::release_create_asset() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.create_asset)
  if (has_create_asset()) {
    clear_has_command();
      ::iroha::protocol::CreateAsset* temp = command_.create_asset_;
    command_.create_asset_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::CreateAsset& Command::create_asset() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.create_asset)
  return has_create_asset()
      ? *command_.create_asset_
      : *reinterpret_cast< ::iroha::protocol::CreateAsset*>(&::iroha::protocol::_CreateAsset_default_instance_);
}
inline ::iroha::protocol::CreateAsset* Command::mutable_create_asset() {
  if (!has_create_asset()) {
    clear_command();
    set_has_create_asset();
    command_.create_asset_ = new ::iroha::protocol::CreateAsset;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.create_asset)
  return command_.create_asset_;
}

// .iroha.protocol.CreateDomain create_domain = 7;
inline bool Command::has_create_domain() const {
  return command_case() == kCreateDomain;
}
inline void Command::set_has_create_domain() {
  _oneof_case_[0] = kCreateDomain;
}
inline void Command::clear_create_domain() {
  if (has_create_domain()) {
    delete command_.create_domain_;
    clear_has_command();
  }
}
inline ::iroha::protocol::CreateDomain* Command::release_create_domain() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.create_domain)
  if (has_create_domain()) {
    clear_has_command();
      ::iroha::protocol::CreateDomain* temp = command_.create_domain_;
    command_.create_domain_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::CreateDomain& Command::create_domain() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.create_domain)
  return has_create_domain()
      ? *command_.create_domain_
      : *reinterpret_cast< ::iroha::protocol::CreateDomain*>(&::iroha::protocol::_CreateDomain_default_instance_);
}
inline ::iroha::protocol::CreateDomain* Command::mutable_create_domain() {
  if (!has_create_domain()) {
    clear_command();
    set_has_create_domain();
    command_.create_domain_ = new ::iroha::protocol::CreateDomain;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.create_domain)
  return command_.create_domain_;
}

// .iroha.protocol.CreateRole create_role = 8;
inline bool Command::has_create_role() const {
  return command_case() == kCreateRole;
}
inline void Command::set_has_create_role() {
  _oneof_case_[0] = kCreateRole;
}
inline void Command::clear_create_role() {
  if (has_create_role()) {
    delete command_.create_role_;
    clear_has_command();
  }
}
inline ::iroha::protocol::CreateRole* Command::release_create_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.create_role)
  if (has_create_role()) {
    clear_has_command();
      ::iroha::protocol::CreateRole* temp = command_.create_role_;
    command_.create_role_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::CreateRole& Command::create_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.create_role)
  return has_create_role()
      ? *command_.create_role_
      : *reinterpret_cast< ::iroha::protocol::CreateRole*>(&::iroha::protocol::_CreateRole_default_instance_);
}
inline ::iroha::protocol::CreateRole* Command::mutable_create_role() {
  if (!has_create_role()) {
    clear_command();
    set_has_create_role();
    command_.create_role_ = new ::iroha::protocol::CreateRole;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.create_role)
  return command_.create_role_;
}

// .iroha.protocol.DetachRole detach_role = 9;
inline bool Command::has_detach_role() const {
  return command_case() == kDetachRole;
}
inline void Command::set_has_detach_role() {
  _oneof_case_[0] = kDetachRole;
}
inline void Command::clear_detach_role() {
  if (has_detach_role()) {
    delete command_.detach_role_;
    clear_has_command();
  }
}
inline ::iroha::protocol::DetachRole* Command::release_detach_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.detach_role)
  if (has_detach_role()) {
    clear_has_command();
      ::iroha::protocol::DetachRole* temp = command_.detach_role_;
    command_.detach_role_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::DetachRole& Command::detach_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.detach_role)
  return has_detach_role()
      ? *command_.detach_role_
      : *reinterpret_cast< ::iroha::protocol::DetachRole*>(&::iroha::protocol::_DetachRole_default_instance_);
}
inline ::iroha::protocol::DetachRole* Command::mutable_detach_role() {
  if (!has_detach_role()) {
    clear_command();
    set_has_detach_role();
    command_.detach_role_ = new ::iroha::protocol::DetachRole;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.detach_role)
  return command_.detach_role_;
}

// .iroha.protocol.GrantPermission grant_permission = 10;
inline bool Command::has_grant_permission() const {
  return command_case() == kGrantPermission;
}
inline void Command::set_has_grant_permission() {
  _oneof_case_[0] = kGrantPermission;
}
inline void Command::clear_grant_permission() {
  if (has_grant_permission()) {
    delete command_.grant_permission_;
    clear_has_command();
  }
}
inline ::iroha::protocol::GrantPermission* Command::release_grant_permission() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.grant_permission)
  if (has_grant_permission()) {
    clear_has_command();
      ::iroha::protocol::GrantPermission* temp = command_.grant_permission_;
    command_.grant_permission_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::GrantPermission& Command::grant_permission() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.grant_permission)
  return has_grant_permission()
      ? *command_.grant_permission_
      : *reinterpret_cast< ::iroha::protocol::GrantPermission*>(&::iroha::protocol::_GrantPermission_default_instance_);
}
inline ::iroha::protocol::GrantPermission* Command::mutable_grant_permission() {
  if (!has_grant_permission()) {
    clear_command();
    set_has_grant_permission();
    command_.grant_permission_ = new ::iroha::protocol::GrantPermission;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.grant_permission)
  return command_.grant_permission_;
}

// .iroha.protocol.RemoveSignatory remove_sign = 11;
inline bool Command::has_remove_sign() const {
  return command_case() == kRemoveSign;
}
inline void Command::set_has_remove_sign() {
  _oneof_case_[0] = kRemoveSign;
}
inline void Command::clear_remove_sign() {
  if (has_remove_sign()) {
    delete command_.remove_sign_;
    clear_has_command();
  }
}
inline ::iroha::protocol::RemoveSignatory* Command::release_remove_sign() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.remove_sign)
  if (has_remove_sign()) {
    clear_has_command();
      ::iroha::protocol::RemoveSignatory* temp = command_.remove_sign_;
    command_.remove_sign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::RemoveSignatory& Command::remove_sign() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.remove_sign)
  return has_remove_sign()
      ? *command_.remove_sign_
      : *reinterpret_cast< ::iroha::protocol::RemoveSignatory*>(&::iroha::protocol::_RemoveSignatory_default_instance_);
}
inline ::iroha::protocol::RemoveSignatory* Command::mutable_remove_sign() {
  if (!has_remove_sign()) {
    clear_command();
    set_has_remove_sign();
    command_.remove_sign_ = new ::iroha::protocol::RemoveSignatory;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.remove_sign)
  return command_.remove_sign_;
}

// .iroha.protocol.RevokePermission revoke_permission = 12;
inline bool Command::has_revoke_permission() const {
  return command_case() == kRevokePermission;
}
inline void Command::set_has_revoke_permission() {
  _oneof_case_[0] = kRevokePermission;
}
inline void Command::clear_revoke_permission() {
  if (has_revoke_permission()) {
    delete command_.revoke_permission_;
    clear_has_command();
  }
}
inline ::iroha::protocol::RevokePermission* Command::release_revoke_permission() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.revoke_permission)
  if (has_revoke_permission()) {
    clear_has_command();
      ::iroha::protocol::RevokePermission* temp = command_.revoke_permission_;
    command_.revoke_permission_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::RevokePermission& Command::revoke_permission() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.revoke_permission)
  return has_revoke_permission()
      ? *command_.revoke_permission_
      : *reinterpret_cast< ::iroha::protocol::RevokePermission*>(&::iroha::protocol::_RevokePermission_default_instance_);
}
inline ::iroha::protocol::RevokePermission* Command::mutable_revoke_permission() {
  if (!has_revoke_permission()) {
    clear_command();
    set_has_revoke_permission();
    command_.revoke_permission_ = new ::iroha::protocol::RevokePermission;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.revoke_permission)
  return command_.revoke_permission_;
}

// .iroha.protocol.SetAccountDetail set_account_detail = 13;
inline bool Command::has_set_account_detail() const {
  return command_case() == kSetAccountDetail;
}
inline void Command::set_has_set_account_detail() {
  _oneof_case_[0] = kSetAccountDetail;
}
inline void Command::clear_set_account_detail() {
  if (has_set_account_detail()) {
    delete command_.set_account_detail_;
    clear_has_command();
  }
}
inline ::iroha::protocol::SetAccountDetail* Command::release_set_account_detail() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.set_account_detail)
  if (has_set_account_detail()) {
    clear_has_command();
      ::iroha::protocol::SetAccountDetail* temp = command_.set_account_detail_;
    command_.set_account_detail_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::SetAccountDetail& Command::set_account_detail() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.set_account_detail)
  return has_set_account_detail()
      ? *command_.set_account_detail_
      : *reinterpret_cast< ::iroha::protocol::SetAccountDetail*>(&::iroha::protocol::_SetAccountDetail_default_instance_);
}
inline ::iroha::protocol::SetAccountDetail* Command::mutable_set_account_detail() {
  if (!has_set_account_detail()) {
    clear_command();
    set_has_set_account_detail();
    command_.set_account_detail_ = new ::iroha::protocol::SetAccountDetail;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.set_account_detail)
  return command_.set_account_detail_;
}

// .iroha.protocol.SetAccountQuorum set_quorum = 14;
inline bool Command::has_set_quorum() const {
  return command_case() == kSetQuorum;
}
inline void Command::set_has_set_quorum() {
  _oneof_case_[0] = kSetQuorum;
}
inline void Command::clear_set_quorum() {
  if (has_set_quorum()) {
    delete command_.set_quorum_;
    clear_has_command();
  }
}
inline ::iroha::protocol::SetAccountQuorum* Command::release_set_quorum() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.set_quorum)
  if (has_set_quorum()) {
    clear_has_command();
      ::iroha::protocol::SetAccountQuorum* temp = command_.set_quorum_;
    command_.set_quorum_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::SetAccountQuorum& Command::set_quorum() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.set_quorum)
  return has_set_quorum()
      ? *command_.set_quorum_
      : *reinterpret_cast< ::iroha::protocol::SetAccountQuorum*>(&::iroha::protocol::_SetAccountQuorum_default_instance_);
}
inline ::iroha::protocol::SetAccountQuorum* Command::mutable_set_quorum() {
  if (!has_set_quorum()) {
    clear_command();
    set_has_set_quorum();
    command_.set_quorum_ = new ::iroha::protocol::SetAccountQuorum;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.set_quorum)
  return command_.set_quorum_;
}

// .iroha.protocol.SubtractAssetQuantity subtract_asset_quantity = 15;
inline bool Command::has_subtract_asset_quantity() const {
  return command_case() == kSubtractAssetQuantity;
}
inline void Command::set_has_subtract_asset_quantity() {
  _oneof_case_[0] = kSubtractAssetQuantity;
}
inline void Command::clear_subtract_asset_quantity() {
  if (has_subtract_asset_quantity()) {
    delete command_.subtract_asset_quantity_;
    clear_has_command();
  }
}
inline ::iroha::protocol::SubtractAssetQuantity* Command::release_subtract_asset_quantity() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.subtract_asset_quantity)
  if (has_subtract_asset_quantity()) {
    clear_has_command();
      ::iroha::protocol::SubtractAssetQuantity* temp = command_.subtract_asset_quantity_;
    command_.subtract_asset_quantity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::SubtractAssetQuantity& Command::subtract_asset_quantity() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.subtract_asset_quantity)
  return has_subtract_asset_quantity()
      ? *command_.subtract_asset_quantity_
      : *reinterpret_cast< ::iroha::protocol::SubtractAssetQuantity*>(&::iroha::protocol::_SubtractAssetQuantity_default_instance_);
}
inline ::iroha::protocol::SubtractAssetQuantity* Command::mutable_subtract_asset_quantity() {
  if (!has_subtract_asset_quantity()) {
    clear_command();
    set_has_subtract_asset_quantity();
    command_.subtract_asset_quantity_ = new ::iroha::protocol::SubtractAssetQuantity;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.subtract_asset_quantity)
  return command_.subtract_asset_quantity_;
}

// .iroha.protocol.TransferAsset transfer_asset = 16;
inline bool Command::has_transfer_asset() const {
  return command_case() == kTransferAsset;
}
inline void Command::set_has_transfer_asset() {
  _oneof_case_[0] = kTransferAsset;
}
inline void Command::clear_transfer_asset() {
  if (has_transfer_asset()) {
    delete command_.transfer_asset_;
    clear_has_command();
  }
}
inline ::iroha::protocol::TransferAsset* Command::release_transfer_asset() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.transfer_asset)
  if (has_transfer_asset()) {
    clear_has_command();
      ::iroha::protocol::TransferAsset* temp = command_.transfer_asset_;
    command_.transfer_asset_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::iroha::protocol::TransferAsset& Command::transfer_asset() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.transfer_asset)
  return has_transfer_asset()
      ? *command_.transfer_asset_
      : *reinterpret_cast< ::iroha::protocol::TransferAsset*>(&::iroha::protocol::_TransferAsset_default_instance_);
}
inline ::iroha::protocol::TransferAsset* Command::mutable_transfer_asset() {
  if (!has_transfer_asset()) {
    clear_command();
    set_has_transfer_asset();
    command_.transfer_asset_ = new ::iroha::protocol::TransferAsset;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.transfer_asset)
  return command_.transfer_asset_;
}

inline bool Command::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void Command::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline Command::CommandCase Command::command_case() const {
  return Command::CommandCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace iroha

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_commands_2eproto__INCLUDED
