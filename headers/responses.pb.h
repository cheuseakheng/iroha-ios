// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: responses.proto

#ifndef PROTOBUF_responses_2eproto__INCLUDED
#define PROTOBUF_responses_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "block.pb.h"
#include "primitive.pb.h"
// @@protoc_insertion_point(includes)
namespace iroha {
namespace protocol {
class Account;
class AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountAsset;
class AccountAssetDefaultTypeInternal;
extern AccountAssetDefaultTypeInternal _AccountAsset_default_instance_;
class AccountAssetResponse;
class AccountAssetResponseDefaultTypeInternal;
extern AccountAssetResponseDefaultTypeInternal _AccountAssetResponse_default_instance_;
class AccountDetailResponse;
class AccountDetailResponseDefaultTypeInternal;
extern AccountDetailResponseDefaultTypeInternal _AccountDetailResponse_default_instance_;
class AccountResponse;
class AccountResponseDefaultTypeInternal;
extern AccountResponseDefaultTypeInternal _AccountResponse_default_instance_;
class Asset;
class AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class AssetResponse;
class AssetResponseDefaultTypeInternal;
extern AssetResponseDefaultTypeInternal _AssetResponse_default_instance_;
class Domain;
class DomainDefaultTypeInternal;
extern DomainDefaultTypeInternal _Domain_default_instance_;
class ErrorResponse;
class ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class QueryResponse;
class QueryResponseDefaultTypeInternal;
extern QueryResponseDefaultTypeInternal _QueryResponse_default_instance_;
class RolePermissionsResponse;
class RolePermissionsResponseDefaultTypeInternal;
extern RolePermissionsResponseDefaultTypeInternal _RolePermissionsResponse_default_instance_;
class RolesResponse;
class RolesResponseDefaultTypeInternal;
extern RolesResponseDefaultTypeInternal _RolesResponse_default_instance_;
class SignatoriesResponse;
class SignatoriesResponseDefaultTypeInternal;
extern SignatoriesResponseDefaultTypeInternal _SignatoriesResponse_default_instance_;
class TransactionsResponse;
class TransactionsResponseDefaultTypeInternal;
extern TransactionsResponseDefaultTypeInternal _TransactionsResponse_default_instance_;
}  // namespace protocol
}  // namespace iroha

namespace iroha {
namespace protocol {

namespace protobuf_responses_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_responses_2eproto

enum ErrorResponse_Reason {
  ErrorResponse_Reason_STATELESS_INVALID = 0,
  ErrorResponse_Reason_STATEFUL_INVALID = 1,
  ErrorResponse_Reason_NO_ACCOUNT = 2,
  ErrorResponse_Reason_NO_ACCOUNT_ASSETS = 3,
  ErrorResponse_Reason_NO_ACCOUNT_DETAIL = 4,
  ErrorResponse_Reason_NO_SIGNATORIES = 5,
  ErrorResponse_Reason_NOT_SUPPORTED = 6,
  ErrorResponse_Reason_NO_ASSET = 7,
  ErrorResponse_Reason_NO_ROLES = 8,
  ErrorResponse_Reason_ErrorResponse_Reason_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ErrorResponse_Reason_ErrorResponse_Reason_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ErrorResponse_Reason_IsValid(int value);
const ErrorResponse_Reason ErrorResponse_Reason_Reason_MIN = ErrorResponse_Reason_STATELESS_INVALID;
const ErrorResponse_Reason ErrorResponse_Reason_Reason_MAX = ErrorResponse_Reason_NO_ROLES;
const int ErrorResponse_Reason_Reason_ARRAYSIZE = ErrorResponse_Reason_Reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorResponse_Reason_descriptor();
inline const ::std::string& ErrorResponse_Reason_Name(ErrorResponse_Reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorResponse_Reason_descriptor(), value);
}
inline bool ErrorResponse_Reason_Parse(
    const ::std::string& name, ErrorResponse_Reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorResponse_Reason>(
    ErrorResponse_Reason_descriptor(), name, value);
}
// ===================================================================

class Asset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Asset(Asset&& from) noexcept
    : Asset() {
    *this = ::std::move(from);
  }

  inline Asset& operator=(Asset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Asset& default_instance();

  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
               &_Asset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Asset* other);
  friend void swap(Asset& a, Asset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Asset* New() const PROTOBUF_FINAL { return New(NULL); }

  Asset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Asset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string asset_id = 1;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 1;
  const ::std::string& asset_id() const;
  void set_asset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_id(::std::string&& value);
  #endif
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  ::std::string* mutable_asset_id();
  ::std::string* release_asset_id();
  void set_allocated_asset_id(::std::string* asset_id);

  // string domain_id = 2;
  void clear_domain_id();
  static const int kDomainIdFieldNumber = 2;
  const ::std::string& domain_id() const;
  void set_domain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_id(::std::string&& value);
  #endif
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  ::std::string* mutable_domain_id();
  ::std::string* release_domain_id();
  void set_allocated_domain_id(::std::string* domain_id);

  // uint32 precision = 3;
  void clear_precision();
  static const int kPrecisionFieldNumber = 3;
  ::google::protobuf::uint32 precision() const;
  void set_precision(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iroha.protocol.Asset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asset_id_;
  ::google::protobuf::internal::ArenaStringPtr domain_id_;
  ::google::protobuf::uint32 precision_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Domain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Domain) */ {
 public:
  Domain();
  virtual ~Domain();

  Domain(const Domain& from);

  inline Domain& operator=(const Domain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Domain(Domain&& from) noexcept
    : Domain() {
    *this = ::std::move(from);
  }

  inline Domain& operator=(Domain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Domain& default_instance();

  static inline const Domain* internal_default_instance() {
    return reinterpret_cast<const Domain*>(
               &_Domain_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Domain* other);
  friend void swap(Domain& a, Domain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Domain* New() const PROTOBUF_FINAL { return New(NULL); }

  Domain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Domain& from);
  void MergeFrom(const Domain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Domain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string domain_id = 1;
  void clear_domain_id();
  static const int kDomainIdFieldNumber = 1;
  const ::std::string& domain_id() const;
  void set_domain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_id(::std::string&& value);
  #endif
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  ::std::string* mutable_domain_id();
  ::std::string* release_domain_id();
  void set_allocated_domain_id(::std::string* domain_id);

  // string default_role = 2;
  void clear_default_role();
  static const int kDefaultRoleFieldNumber = 2;
  const ::std::string& default_role() const;
  void set_default_role(const ::std::string& value);
  #if LANG_CXX11
  void set_default_role(::std::string&& value);
  #endif
  void set_default_role(const char* value);
  void set_default_role(const char* value, size_t size);
  ::std::string* mutable_default_role();
  ::std::string* release_default_role();
  void set_allocated_default_role(::std::string* default_role);

  // @@protoc_insertion_point(class_scope:iroha.protocol.Domain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr domain_id_;
  ::google::protobuf::internal::ArenaStringPtr default_role_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(Account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Account* other);
  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Account* New() const PROTOBUF_FINAL { return New(NULL); }

  Account* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // string domain_id = 2;
  void clear_domain_id();
  static const int kDomainIdFieldNumber = 2;
  const ::std::string& domain_id() const;
  void set_domain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_id(::std::string&& value);
  #endif
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  ::std::string* mutable_domain_id();
  ::std::string* release_domain_id();
  void set_allocated_domain_id(::std::string* domain_id);

  // string json_data = 4;
  void clear_json_data();
  static const int kJsonDataFieldNumber = 4;
  const ::std::string& json_data() const;
  void set_json_data(const ::std::string& value);
  #if LANG_CXX11
  void set_json_data(::std::string&& value);
  #endif
  void set_json_data(const char* value);
  void set_json_data(const char* value, size_t size);
  ::std::string* mutable_json_data();
  ::std::string* release_json_data();
  void set_allocated_json_data(::std::string* json_data);

  // uint32 quorum = 3;
  void clear_quorum();
  static const int kQuorumFieldNumber = 3;
  ::google::protobuf::uint32 quorum() const;
  void set_quorum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:iroha.protocol.Account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr domain_id_;
  ::google::protobuf::internal::ArenaStringPtr json_data_;
  ::google::protobuf::uint32 quorum_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountAsset) */ {
 public:
  AccountAsset();
  virtual ~AccountAsset();

  AccountAsset(const AccountAsset& from);

  inline AccountAsset& operator=(const AccountAsset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountAsset(AccountAsset&& from) noexcept
    : AccountAsset() {
    *this = ::std::move(from);
  }

  inline AccountAsset& operator=(AccountAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountAsset& default_instance();

  static inline const AccountAsset* internal_default_instance() {
    return reinterpret_cast<const AccountAsset*>(
               &_AccountAsset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AccountAsset* other);
  friend void swap(AccountAsset& a, AccountAsset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountAsset* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountAsset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountAsset& from);
  void MergeFrom(const AccountAsset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string asset_id = 1;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 1;
  const ::std::string& asset_id() const;
  void set_asset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_id(::std::string&& value);
  #endif
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  ::std::string* mutable_asset_id();
  ::std::string* release_asset_id();
  void set_allocated_asset_id(::std::string* asset_id);

  // string account_id = 2;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // .iroha.protocol.Amount balance = 3;
  bool has_balance() const;
  void clear_balance();
  static const int kBalanceFieldNumber = 3;
  const ::iroha::protocol::Amount& balance() const;
  ::iroha::protocol::Amount* mutable_balance();
  ::iroha::protocol::Amount* release_balance();
  void set_allocated_balance(::iroha::protocol::Amount* balance);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountAsset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asset_id_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::iroha::protocol::Amount* balance_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountAssetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountAssetResponse) */ {
 public:
  AccountAssetResponse();
  virtual ~AccountAssetResponse();

  AccountAssetResponse(const AccountAssetResponse& from);

  inline AccountAssetResponse& operator=(const AccountAssetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountAssetResponse(AccountAssetResponse&& from) noexcept
    : AccountAssetResponse() {
    *this = ::std::move(from);
  }

  inline AccountAssetResponse& operator=(AccountAssetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountAssetResponse& default_instance();

  static inline const AccountAssetResponse* internal_default_instance() {
    return reinterpret_cast<const AccountAssetResponse*>(
               &_AccountAssetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AccountAssetResponse* other);
  friend void swap(AccountAssetResponse& a, AccountAssetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountAssetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountAssetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountAssetResponse& from);
  void MergeFrom(const AccountAssetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountAssetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iroha.protocol.AccountAsset account_asset = 1;
  bool has_account_asset() const;
  void clear_account_asset();
  static const int kAccountAssetFieldNumber = 1;
  const ::iroha::protocol::AccountAsset& account_asset() const;
  ::iroha::protocol::AccountAsset* mutable_account_asset();
  ::iroha::protocol::AccountAsset* release_account_asset();
  void set_allocated_account_asset(::iroha::protocol::AccountAsset* account_asset);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountAssetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iroha::protocol::AccountAsset* account_asset_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountDetailResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountDetailResponse) */ {
 public:
  AccountDetailResponse();
  virtual ~AccountDetailResponse();

  AccountDetailResponse(const AccountDetailResponse& from);

  inline AccountDetailResponse& operator=(const AccountDetailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountDetailResponse(AccountDetailResponse&& from) noexcept
    : AccountDetailResponse() {
    *this = ::std::move(from);
  }

  inline AccountDetailResponse& operator=(AccountDetailResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountDetailResponse& default_instance();

  static inline const AccountDetailResponse* internal_default_instance() {
    return reinterpret_cast<const AccountDetailResponse*>(
               &_AccountDetailResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AccountDetailResponse* other);
  friend void swap(AccountDetailResponse& a, AccountDetailResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountDetailResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountDetailResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountDetailResponse& from);
  void MergeFrom(const AccountDetailResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountDetailResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string detail = 1;
  void clear_detail();
  static const int kDetailFieldNumber = 1;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountDetailResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountResponse) */ {
 public:
  AccountResponse();
  virtual ~AccountResponse();

  AccountResponse(const AccountResponse& from);

  inline AccountResponse& operator=(const AccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountResponse(AccountResponse&& from) noexcept
    : AccountResponse() {
    *this = ::std::move(from);
  }

  inline AccountResponse& operator=(AccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountResponse& default_instance();

  static inline const AccountResponse* internal_default_instance() {
    return reinterpret_cast<const AccountResponse*>(
               &_AccountResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AccountResponse* other);
  friend void swap(AccountResponse& a, AccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountResponse& from);
  void MergeFrom(const AccountResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string account_roles = 2;
  int account_roles_size() const;
  void clear_account_roles();
  static const int kAccountRolesFieldNumber = 2;
  const ::std::string& account_roles(int index) const;
  ::std::string* mutable_account_roles(int index);
  void set_account_roles(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_account_roles(int index, ::std::string&& value);
  #endif
  void set_account_roles(int index, const char* value);
  void set_account_roles(int index, const char* value, size_t size);
  ::std::string* add_account_roles();
  void add_account_roles(const ::std::string& value);
  #if LANG_CXX11
  void add_account_roles(::std::string&& value);
  #endif
  void add_account_roles(const char* value);
  void add_account_roles(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& account_roles() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_account_roles();

  // .iroha.protocol.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::iroha::protocol::Account& account() const;
  ::iroha::protocol::Account* mutable_account();
  ::iroha::protocol::Account* release_account();
  void set_allocated_account(::iroha::protocol::Account* account);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> account_roles_;
  ::iroha::protocol::Account* account_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AssetResponse) */ {
 public:
  AssetResponse();
  virtual ~AssetResponse();

  AssetResponse(const AssetResponse& from);

  inline AssetResponse& operator=(const AssetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetResponse(AssetResponse&& from) noexcept
    : AssetResponse() {
    *this = ::std::move(from);
  }

  inline AssetResponse& operator=(AssetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetResponse& default_instance();

  static inline const AssetResponse* internal_default_instance() {
    return reinterpret_cast<const AssetResponse*>(
               &_AssetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(AssetResponse* other);
  friend void swap(AssetResponse& a, AssetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AssetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AssetResponse& from);
  void MergeFrom(const AssetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AssetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .iroha.protocol.Asset asset = 1;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 1;
  const ::iroha::protocol::Asset& asset() const;
  ::iroha::protocol::Asset* mutable_asset();
  ::iroha::protocol::Asset* release_asset();
  void set_allocated_asset(::iroha::protocol::Asset* asset);

  // @@protoc_insertion_point(class_scope:iroha.protocol.AssetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iroha::protocol::Asset* asset_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RolesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RolesResponse) */ {
 public:
  RolesResponse();
  virtual ~RolesResponse();

  RolesResponse(const RolesResponse& from);

  inline RolesResponse& operator=(const RolesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RolesResponse(RolesResponse&& from) noexcept
    : RolesResponse() {
    *this = ::std::move(from);
  }

  inline RolesResponse& operator=(RolesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RolesResponse& default_instance();

  static inline const RolesResponse* internal_default_instance() {
    return reinterpret_cast<const RolesResponse*>(
               &_RolesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(RolesResponse* other);
  friend void swap(RolesResponse& a, RolesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RolesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RolesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RolesResponse& from);
  void MergeFrom(const RolesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RolesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string roles = 1;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 1;
  const ::std::string& roles(int index) const;
  ::std::string* mutable_roles(int index);
  void set_roles(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_roles(int index, ::std::string&& value);
  #endif
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, size_t size);
  ::std::string* add_roles();
  void add_roles(const ::std::string& value);
  #if LANG_CXX11
  void add_roles(::std::string&& value);
  #endif
  void add_roles(const char* value);
  void add_roles(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& roles() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roles();

  // @@protoc_insertion_point(class_scope:iroha.protocol.RolesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> roles_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RolePermissionsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RolePermissionsResponse) */ {
 public:
  RolePermissionsResponse();
  virtual ~RolePermissionsResponse();

  RolePermissionsResponse(const RolePermissionsResponse& from);

  inline RolePermissionsResponse& operator=(const RolePermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RolePermissionsResponse(RolePermissionsResponse&& from) noexcept
    : RolePermissionsResponse() {
    *this = ::std::move(from);
  }

  inline RolePermissionsResponse& operator=(RolePermissionsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RolePermissionsResponse& default_instance();

  static inline const RolePermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const RolePermissionsResponse*>(
               &_RolePermissionsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RolePermissionsResponse* other);
  friend void swap(RolePermissionsResponse& a, RolePermissionsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RolePermissionsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RolePermissionsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RolePermissionsResponse& from);
  void MergeFrom(const RolePermissionsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RolePermissionsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string permissions = 1;
  int permissions_size() const;
  void clear_permissions();
  static const int kPermissionsFieldNumber = 1;
  const ::std::string& permissions(int index) const;
  ::std::string* mutable_permissions(int index);
  void set_permissions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_permissions(int index, ::std::string&& value);
  #endif
  void set_permissions(int index, const char* value);
  void set_permissions(int index, const char* value, size_t size);
  ::std::string* add_permissions();
  void add_permissions(const ::std::string& value);
  #if LANG_CXX11
  void add_permissions(::std::string&& value);
  #endif
  void add_permissions(const char* value);
  void add_permissions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& permissions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_permissions();

  // @@protoc_insertion_point(class_scope:iroha.protocol.RolePermissionsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> permissions_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ErrorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.ErrorResponse) */ {
 public:
  ErrorResponse();
  virtual ~ErrorResponse();

  ErrorResponse(const ErrorResponse& from);

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorResponse& default_instance();

  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ErrorResponse* other);
  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ErrorResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ErrorResponse& from);
  void MergeFrom(const ErrorResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ErrorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ErrorResponse_Reason Reason;
  static const Reason STATELESS_INVALID =
    ErrorResponse_Reason_STATELESS_INVALID;
  static const Reason STATEFUL_INVALID =
    ErrorResponse_Reason_STATEFUL_INVALID;
  static const Reason NO_ACCOUNT =
    ErrorResponse_Reason_NO_ACCOUNT;
  static const Reason NO_ACCOUNT_ASSETS =
    ErrorResponse_Reason_NO_ACCOUNT_ASSETS;
  static const Reason NO_ACCOUNT_DETAIL =
    ErrorResponse_Reason_NO_ACCOUNT_DETAIL;
  static const Reason NO_SIGNATORIES =
    ErrorResponse_Reason_NO_SIGNATORIES;
  static const Reason NOT_SUPPORTED =
    ErrorResponse_Reason_NOT_SUPPORTED;
  static const Reason NO_ASSET =
    ErrorResponse_Reason_NO_ASSET;
  static const Reason NO_ROLES =
    ErrorResponse_Reason_NO_ROLES;
  static inline bool Reason_IsValid(int value) {
    return ErrorResponse_Reason_IsValid(value);
  }
  static const Reason Reason_MIN =
    ErrorResponse_Reason_Reason_MIN;
  static const Reason Reason_MAX =
    ErrorResponse_Reason_Reason_MAX;
  static const int Reason_ARRAYSIZE =
    ErrorResponse_Reason_Reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Reason_descriptor() {
    return ErrorResponse_Reason_descriptor();
  }
  static inline const ::std::string& Reason_Name(Reason value) {
    return ErrorResponse_Reason_Name(value);
  }
  static inline bool Reason_Parse(const ::std::string& name,
      Reason* value) {
    return ErrorResponse_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .iroha.protocol.ErrorResponse.Reason reason = 1;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  ::iroha::protocol::ErrorResponse_Reason reason() const;
  void set_reason(::iroha::protocol::ErrorResponse_Reason value);

  // @@protoc_insertion_point(class_scope:iroha.protocol.ErrorResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int reason_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignatoriesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SignatoriesResponse) */ {
 public:
  SignatoriesResponse();
  virtual ~SignatoriesResponse();

  SignatoriesResponse(const SignatoriesResponse& from);

  inline SignatoriesResponse& operator=(const SignatoriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignatoriesResponse(SignatoriesResponse&& from) noexcept
    : SignatoriesResponse() {
    *this = ::std::move(from);
  }

  inline SignatoriesResponse& operator=(SignatoriesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignatoriesResponse& default_instance();

  static inline const SignatoriesResponse* internal_default_instance() {
    return reinterpret_cast<const SignatoriesResponse*>(
               &_SignatoriesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SignatoriesResponse* other);
  friend void swap(SignatoriesResponse& a, SignatoriesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignatoriesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SignatoriesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignatoriesResponse& from);
  void MergeFrom(const SignatoriesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignatoriesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:iroha.protocol.SignatoriesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.TransactionsResponse) */ {
 public:
  TransactionsResponse();
  virtual ~TransactionsResponse();

  TransactionsResponse(const TransactionsResponse& from);

  inline TransactionsResponse& operator=(const TransactionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionsResponse(TransactionsResponse&& from) noexcept
    : TransactionsResponse() {
    *this = ::std::move(from);
  }

  inline TransactionsResponse& operator=(TransactionsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionsResponse& default_instance();

  static inline const TransactionsResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionsResponse*>(
               &_TransactionsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TransactionsResponse* other);
  friend void swap(TransactionsResponse& a, TransactionsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionsResponse& from);
  void MergeFrom(const TransactionsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .iroha.protocol.Transaction transactions = 1;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 1;
  const ::iroha::protocol::Transaction& transactions(int index) const;
  ::iroha::protocol::Transaction* mutable_transactions(int index);
  ::iroha::protocol::Transaction* add_transactions();
  ::google::protobuf::RepeatedPtrField< ::iroha::protocol::Transaction >*
      mutable_transactions();
  const ::google::protobuf::RepeatedPtrField< ::iroha::protocol::Transaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:iroha.protocol.TransactionsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::iroha::protocol::Transaction > transactions_;
  mutable int _cached_size_;
  friend struct protobuf_responses_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.QueryResponse) */ {
 public:
  QueryResponse();
  virtual ~QueryResponse();

  QueryResponse(const QueryResponse& from);

  inline QueryResponse& operator=(const QueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryResponse(QueryResponse&& from) noexcept
    : QueryResponse() {
    *this = ::std::move(from);
  }

  inline QueryResponse& operator=(QueryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryResponse& default_instance();

  enum ResponseCase {
    kAccountAssetsResponse = 1,
    kAccountDetailResponse = 2,
    kAccountResponse = 3,
    kErrorResponse = 4,
    kSignatoriesResponse = 5,
    kTransactionsResponse = 6,
    kAssetResponse = 7,
    kRolesResponse = 8,
    kRolePermissionsResponse = 9,
    RESPONSE_NOT_SET = 0,
  };

  static inline const QueryResponse* internal_default_instance() {
    return reinterpret_cast<const QueryResponse*>(
               &_QueryResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(QueryResponse* other);
  friend void swap(QueryResponse& a, QueryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryResponse& from);
  void MergeFrom(const QueryResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes query_hash = 10;
  void clear_query_hash();
  static const int kQueryHashFieldNumber = 10;
  const ::std::string& query_hash() const;
  void set_query_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_query_hash(::std::string&& value);
  #endif
  void set_query_hash(const char* value);
  void set_query_hash(const void* value, size_t size);
  ::std::string* mutable_query_hash();
  ::std::string* release_query_hash();
  void set_allocated_query_hash(::std::string* query_hash);

  // .iroha.protocol.AccountAssetResponse account_assets_response = 1;
  bool has_account_assets_response() const;
  void clear_account_assets_response();
  static const int kAccountAssetsResponseFieldNumber = 1;
  const ::iroha::protocol::AccountAssetResponse& account_assets_response() const;
  ::iroha::protocol::AccountAssetResponse* mutable_account_assets_response();
  ::iroha::protocol::AccountAssetResponse* release_account_assets_response();
  void set_allocated_account_assets_response(::iroha::protocol::AccountAssetResponse* account_assets_response);

  // .iroha.protocol.AccountDetailResponse account_detail_response = 2;
  bool has_account_detail_response() const;
  void clear_account_detail_response();
  static const int kAccountDetailResponseFieldNumber = 2;
  const ::iroha::protocol::AccountDetailResponse& account_detail_response() const;
  ::iroha::protocol::AccountDetailResponse* mutable_account_detail_response();
  ::iroha::protocol::AccountDetailResponse* release_account_detail_response();
  void set_allocated_account_detail_response(::iroha::protocol::AccountDetailResponse* account_detail_response);

  // .iroha.protocol.AccountResponse account_response = 3;
  bool has_account_response() const;
  void clear_account_response();
  static const int kAccountResponseFieldNumber = 3;
  const ::iroha::protocol::AccountResponse& account_response() const;
  ::iroha::protocol::AccountResponse* mutable_account_response();
  ::iroha::protocol::AccountResponse* release_account_response();
  void set_allocated_account_response(::iroha::protocol::AccountResponse* account_response);

  // .iroha.protocol.ErrorResponse error_response = 4;
  bool has_error_response() const;
  void clear_error_response();
  static const int kErrorResponseFieldNumber = 4;
  const ::iroha::protocol::ErrorResponse& error_response() const;
  ::iroha::protocol::ErrorResponse* mutable_error_response();
  ::iroha::protocol::ErrorResponse* release_error_response();
  void set_allocated_error_response(::iroha::protocol::ErrorResponse* error_response);

  // .iroha.protocol.SignatoriesResponse signatories_response = 5;
  bool has_signatories_response() const;
  void clear_signatories_response();
  static const int kSignatoriesResponseFieldNumber = 5;
  const ::iroha::protocol::SignatoriesResponse& signatories_response() const;
  ::iroha::protocol::SignatoriesResponse* mutable_signatories_response();
  ::iroha::protocol::SignatoriesResponse* release_signatories_response();
  void set_allocated_signatories_response(::iroha::protocol::SignatoriesResponse* signatories_response);

  // .iroha.protocol.TransactionsResponse transactions_response = 6;
  bool has_transactions_response() const;
  void clear_transactions_response();
  static const int kTransactionsResponseFieldNumber = 6;
  const ::iroha::protocol::TransactionsResponse& transactions_response() const;
  ::iroha::protocol::TransactionsResponse* mutable_transactions_response();
  ::iroha::protocol::TransactionsResponse* release_transactions_response();
  void set_allocated_transactions_response(::iroha::protocol::TransactionsResponse* transactions_response);

  // .iroha.protocol.AssetResponse asset_response = 7;
  bool has_asset_response() const;
  void clear_asset_response();
  static const int kAssetResponseFieldNumber = 7;
  const ::iroha::protocol::AssetResponse& asset_response() const;
  ::iroha::protocol::AssetResponse* mutable_asset_response();
  ::iroha::protocol::AssetResponse* release_asset_response();
  void set_allocated_asset_response(::iroha::protocol::AssetResponse* asset_response);

  // .iroha.protocol.RolesResponse roles_response = 8;
  bool has_roles_response() const;
  void clear_roles_response();
  static const int kRolesResponseFieldNumber = 8;
  const ::iroha::protocol::RolesResponse& roles_response() const;
  ::iroha::protocol::RolesResponse* mutable_roles_response();
  ::iroha::protocol::RolesResponse* release_roles_response();
  void set_allocated_roles_response(::iroha::protocol::RolesResponse* roles_response);

  // .iroha.protocol.RolePermissionsResponse role_permissions_response = 9;
  bool has_role_permissions_response() const;
  void clear_role_permissions_response();
  static const int kRolePermissionsResponseFieldNumber = 9;
  const ::iroha::protocol::RolePermissionsResponse& role_permissions_response() const;
  ::iroha::protocol::RolePermissionsResponse* mutable_role_permissions_response();
  ::iroha::protocol::RolePermissionsResponse* release_role_permissions_response();
  void set_allocated_role_permissions_response(::iroha::protocol::RolePermissionsResponse* role_permissions_response);

  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.QueryResponse)
 private:
  void set_has_account_assets_response();
  void set_has_account_detail_response();
  void set_has_account_response();
  void set_has_error_response();
  void set_has_signatories_response();
  void set_has_transactions_response();
  void set_has_asset_response();
  void set_has_roles_response();
  void set_has_role_permissions_response();

  inline bool has_response() const;
  void clear_response();
  inline void clear_has_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr query_hash_;
  union ResponseUnion {
    ResponseUnion() {}
    ::iroha::protocol::AccountAssetResponse* account_assets_response_;
    ::iroha::protocol::AccountDetailResponse* account_detail_response_;
    ::iroha::protocol::AccountResponse* account_response_;
    ::iroha::protocol::ErrorResponse* error_response_;
    ::iroha::protocol::SignatoriesResponse* signatories_response_;
    ::iroha::protocol::TransactionsResponse* transactions_response_;
    ::iroha::protocol::AssetResponse* asset_response_;
    ::iroha::protocol::RolesResponse* roles_response_;
    ::iroha::protocol::RolePermissionsResponse* role_permissions_response_;
  } response_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_responses_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Asset

// string asset_id = 1;
inline void Asset::clear_asset_id() {
  asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Asset.asset_id)
  return asset_id_.GetNoArena();
}
inline void Asset::set_asset_id(const ::std::string& value) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Asset.asset_id)
}
#if LANG_CXX11
inline void Asset::set_asset_id(::std::string&& value) {
  
  asset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Asset.asset_id)
}
#endif
inline void Asset::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Asset.asset_id)
}
inline void Asset::set_asset_id(const char* value, size_t size) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Asset.asset_id)
}
inline ::std::string* Asset::mutable_asset_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Asset.asset_id)
  return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Asset.asset_id)
  
  return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id != NULL) {
    
  } else {
    
  }
  asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Asset.asset_id)
}

// string domain_id = 2;
inline void Asset::clear_domain_id() {
  domain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Asset.domain_id)
  return domain_id_.GetNoArena();
}
inline void Asset::set_domain_id(const ::std::string& value) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Asset.domain_id)
}
#if LANG_CXX11
inline void Asset::set_domain_id(::std::string&& value) {
  
  domain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Asset.domain_id)
}
#endif
inline void Asset::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Asset.domain_id)
}
inline void Asset::set_domain_id(const char* value, size_t size) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Asset.domain_id)
}
inline ::std::string* Asset::mutable_domain_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Asset.domain_id)
  return domain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Asset.domain_id)
  
  return domain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_domain_id(::std::string* domain_id) {
  if (domain_id != NULL) {
    
  } else {
    
  }
  domain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Asset.domain_id)
}

// uint32 precision = 3;
inline void Asset::clear_precision() {
  precision_ = 0u;
}
inline ::google::protobuf::uint32 Asset::precision() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Asset.precision)
  return precision_;
}
inline void Asset::set_precision(::google::protobuf::uint32 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.Asset.precision)
}

// -------------------------------------------------------------------

// Domain

// string domain_id = 1;
inline void Domain::clear_domain_id() {
  domain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Domain.domain_id)
  return domain_id_.GetNoArena();
}
inline void Domain::set_domain_id(const ::std::string& value) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Domain.domain_id)
}
#if LANG_CXX11
inline void Domain::set_domain_id(::std::string&& value) {
  
  domain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Domain.domain_id)
}
#endif
inline void Domain::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Domain.domain_id)
}
inline void Domain::set_domain_id(const char* value, size_t size) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Domain.domain_id)
}
inline ::std::string* Domain::mutable_domain_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Domain.domain_id)
  return domain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Domain.domain_id)
  
  return domain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_domain_id(::std::string* domain_id) {
  if (domain_id != NULL) {
    
  } else {
    
  }
  domain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Domain.domain_id)
}

// string default_role = 2;
inline void Domain::clear_default_role() {
  default_role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::default_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Domain.default_role)
  return default_role_.GetNoArena();
}
inline void Domain::set_default_role(const ::std::string& value) {
  
  default_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Domain.default_role)
}
#if LANG_CXX11
inline void Domain::set_default_role(::std::string&& value) {
  
  default_role_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Domain.default_role)
}
#endif
inline void Domain::set_default_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  default_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Domain.default_role)
}
inline void Domain::set_default_role(const char* value, size_t size) {
  
  default_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Domain.default_role)
}
inline ::std::string* Domain::mutable_default_role() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Domain.default_role)
  return default_role_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_default_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Domain.default_role)
  
  return default_role_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_default_role(::std::string* default_role) {
  if (default_role != NULL) {
    
  } else {
    
  }
  default_role_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_role);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Domain.default_role)
}

// -------------------------------------------------------------------

// Account

// string account_id = 1;
inline void Account::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Account.account_id)
  return account_id_.GetNoArena();
}
inline void Account::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Account.account_id)
}
#if LANG_CXX11
inline void Account::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Account.account_id)
}
#endif
inline void Account::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Account.account_id)
}
inline void Account::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Account.account_id)
}
inline ::std::string* Account::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Account.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Account.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Account.account_id)
}

// string domain_id = 2;
inline void Account::clear_domain_id() {
  domain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Account.domain_id)
  return domain_id_.GetNoArena();
}
inline void Account::set_domain_id(const ::std::string& value) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Account.domain_id)
}
#if LANG_CXX11
inline void Account::set_domain_id(::std::string&& value) {
  
  domain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Account.domain_id)
}
#endif
inline void Account::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Account.domain_id)
}
inline void Account::set_domain_id(const char* value, size_t size) {
  
  domain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Account.domain_id)
}
inline ::std::string* Account::mutable_domain_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Account.domain_id)
  return domain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Account.domain_id)
  
  return domain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_domain_id(::std::string* domain_id) {
  if (domain_id != NULL) {
    
  } else {
    
  }
  domain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Account.domain_id)
}

// uint32 quorum = 3;
inline void Account::clear_quorum() {
  quorum_ = 0u;
}
inline ::google::protobuf::uint32 Account::quorum() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Account.quorum)
  return quorum_;
}
inline void Account::set_quorum(::google::protobuf::uint32 value) {
  
  quorum_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.Account.quorum)
}

// string json_data = 4;
inline void Account::clear_json_data() {
  json_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::json_data() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Account.json_data)
  return json_data_.GetNoArena();
}
inline void Account::set_json_data(const ::std::string& value) {
  
  json_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Account.json_data)
}
#if LANG_CXX11
inline void Account::set_json_data(::std::string&& value) {
  
  json_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Account.json_data)
}
#endif
inline void Account::set_json_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  json_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Account.json_data)
}
inline void Account::set_json_data(const char* value, size_t size) {
  
  json_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Account.json_data)
}
inline ::std::string* Account::mutable_json_data() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Account.json_data)
  return json_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_json_data() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Account.json_data)
  
  return json_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_json_data(::std::string* json_data) {
  if (json_data != NULL) {
    
  } else {
    
  }
  json_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), json_data);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Account.json_data)
}

// -------------------------------------------------------------------

// AccountAsset

// string asset_id = 1;
inline void AccountAsset::clear_asset_id() {
  asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountAsset::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAsset.asset_id)
  return asset_id_.GetNoArena();
}
inline void AccountAsset::set_asset_id(const ::std::string& value) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountAsset.asset_id)
}
#if LANG_CXX11
inline void AccountAsset::set_asset_id(::std::string&& value) {
  
  asset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AccountAsset.asset_id)
}
#endif
inline void AccountAsset::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountAsset.asset_id)
}
inline void AccountAsset::set_asset_id(const char* value, size_t size) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountAsset.asset_id)
}
inline ::std::string* AccountAsset::mutable_asset_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAsset.asset_id)
  return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountAsset::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountAsset.asset_id)
  
  return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountAsset::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id != NULL) {
    
  } else {
    
  }
  asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountAsset.asset_id)
}

// string account_id = 2;
inline void AccountAsset::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountAsset::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAsset.account_id)
  return account_id_.GetNoArena();
}
inline void AccountAsset::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountAsset.account_id)
}
#if LANG_CXX11
inline void AccountAsset::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AccountAsset.account_id)
}
#endif
inline void AccountAsset::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountAsset.account_id)
}
inline void AccountAsset::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountAsset.account_id)
}
inline ::std::string* AccountAsset::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAsset.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountAsset::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountAsset.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountAsset::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountAsset.account_id)
}

// .iroha.protocol.Amount balance = 3;
inline bool AccountAsset::has_balance() const {
  return this != internal_default_instance() && balance_ != NULL;
}
inline void AccountAsset::clear_balance() {
  if (GetArenaNoVirtual() == NULL && balance_ != NULL) delete balance_;
  balance_ = NULL;
}
inline const ::iroha::protocol::Amount& AccountAsset::balance() const {
  const ::iroha::protocol::Amount* p = balance_;
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAsset.balance)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Amount*>(
      &::iroha::protocol::_Amount_default_instance_);
}
inline ::iroha::protocol::Amount* AccountAsset::mutable_balance() {
  
  if (balance_ == NULL) {
    balance_ = new ::iroha::protocol::Amount;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAsset.balance)
  return balance_;
}
inline ::iroha::protocol::Amount* AccountAsset::release_balance() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountAsset.balance)
  
  ::iroha::protocol::Amount* temp = balance_;
  balance_ = NULL;
  return temp;
}
inline void AccountAsset::set_allocated_balance(::iroha::protocol::Amount* balance) {
  delete balance_;
  balance_ = balance;
  if (balance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountAsset.balance)
}

// -------------------------------------------------------------------

// AccountAssetResponse

// .iroha.protocol.AccountAsset account_asset = 1;
inline bool AccountAssetResponse::has_account_asset() const {
  return this != internal_default_instance() && account_asset_ != NULL;
}
inline void AccountAssetResponse::clear_account_asset() {
  if (GetArenaNoVirtual() == NULL && account_asset_ != NULL) delete account_asset_;
  account_asset_ = NULL;
}
inline const ::iroha::protocol::AccountAsset& AccountAssetResponse::account_asset() const {
  const ::iroha::protocol::AccountAsset* p = account_asset_;
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAssetResponse.account_asset)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::AccountAsset*>(
      &::iroha::protocol::_AccountAsset_default_instance_);
}
inline ::iroha::protocol::AccountAsset* AccountAssetResponse::mutable_account_asset() {
  
  if (account_asset_ == NULL) {
    account_asset_ = new ::iroha::protocol::AccountAsset;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAssetResponse.account_asset)
  return account_asset_;
}
inline ::iroha::protocol::AccountAsset* AccountAssetResponse::release_account_asset() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountAssetResponse.account_asset)
  
  ::iroha::protocol::AccountAsset* temp = account_asset_;
  account_asset_ = NULL;
  return temp;
}
inline void AccountAssetResponse::set_allocated_account_asset(::iroha::protocol::AccountAsset* account_asset) {
  delete account_asset_;
  account_asset_ = account_asset;
  if (account_asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountAssetResponse.account_asset)
}

// -------------------------------------------------------------------

// AccountDetailResponse

// string detail = 1;
inline void AccountDetailResponse::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountDetailResponse::detail() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountDetailResponse.detail)
  return detail_.GetNoArena();
}
inline void AccountDetailResponse::set_detail(const ::std::string& value) {
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountDetailResponse.detail)
}
#if LANG_CXX11
inline void AccountDetailResponse::set_detail(::std::string&& value) {
  
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AccountDetailResponse.detail)
}
#endif
inline void AccountDetailResponse::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountDetailResponse.detail)
}
inline void AccountDetailResponse::set_detail(const char* value, size_t size) {
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountDetailResponse.detail)
}
inline ::std::string* AccountDetailResponse::mutable_detail() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountDetailResponse.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountDetailResponse::release_detail() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountDetailResponse.detail)
  
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountDetailResponse::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    
  } else {
    
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountDetailResponse.detail)
}

// -------------------------------------------------------------------

// AccountResponse

// .iroha.protocol.Account account = 1;
inline bool AccountResponse::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AccountResponse::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) delete account_;
  account_ = NULL;
}
inline const ::iroha::protocol::Account& AccountResponse::account() const {
  const ::iroha::protocol::Account* p = account_;
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountResponse.account)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Account*>(
      &::iroha::protocol::_Account_default_instance_);
}
inline ::iroha::protocol::Account* AccountResponse::mutable_account() {
  
  if (account_ == NULL) {
    account_ = new ::iroha::protocol::Account;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountResponse.account)
  return account_;
}
inline ::iroha::protocol::Account* AccountResponse::release_account() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountResponse.account)
  
  ::iroha::protocol::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void AccountResponse::set_allocated_account(::iroha::protocol::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountResponse.account)
}

// repeated string account_roles = 2;
inline int AccountResponse::account_roles_size() const {
  return account_roles_.size();
}
inline void AccountResponse::clear_account_roles() {
  account_roles_.Clear();
}
inline const ::std::string& AccountResponse::account_roles(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountResponse.account_roles)
  return account_roles_.Get(index);
}
inline ::std::string* AccountResponse::mutable_account_roles(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountResponse.account_roles)
  return account_roles_.Mutable(index);
}
inline void AccountResponse::set_account_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountResponse.account_roles)
  account_roles_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AccountResponse::set_account_roles(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountResponse.account_roles)
  account_roles_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AccountResponse::set_account_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  account_roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountResponse.account_roles)
}
inline void AccountResponse::set_account_roles(int index, const char* value, size_t size) {
  account_roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountResponse.account_roles)
}
inline ::std::string* AccountResponse::add_account_roles() {
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.AccountResponse.account_roles)
  return account_roles_.Add();
}
inline void AccountResponse::add_account_roles(const ::std::string& value) {
  account_roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.AccountResponse.account_roles)
}
#if LANG_CXX11
inline void AccountResponse::add_account_roles(::std::string&& value) {
  account_roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.AccountResponse.account_roles)
}
#endif
inline void AccountResponse::add_account_roles(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  account_roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.AccountResponse.account_roles)
}
inline void AccountResponse::add_account_roles(const char* value, size_t size) {
  account_roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.AccountResponse.account_roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AccountResponse::account_roles() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.AccountResponse.account_roles)
  return account_roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AccountResponse::mutable_account_roles() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.AccountResponse.account_roles)
  return &account_roles_;
}

// -------------------------------------------------------------------

// AssetResponse

// .iroha.protocol.Asset asset = 1;
inline bool AssetResponse::has_asset() const {
  return this != internal_default_instance() && asset_ != NULL;
}
inline void AssetResponse::clear_asset() {
  if (GetArenaNoVirtual() == NULL && asset_ != NULL) delete asset_;
  asset_ = NULL;
}
inline const ::iroha::protocol::Asset& AssetResponse::asset() const {
  const ::iroha::protocol::Asset* p = asset_;
  // @@protoc_insertion_point(field_get:iroha.protocol.AssetResponse.asset)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Asset*>(
      &::iroha::protocol::_Asset_default_instance_);
}
inline ::iroha::protocol::Asset* AssetResponse::mutable_asset() {
  
  if (asset_ == NULL) {
    asset_ = new ::iroha::protocol::Asset;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AssetResponse.asset)
  return asset_;
}
inline ::iroha::protocol::Asset* AssetResponse::release_asset() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AssetResponse.asset)
  
  ::iroha::protocol::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void AssetResponse::set_allocated_asset(::iroha::protocol::Asset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AssetResponse.asset)
}

// -------------------------------------------------------------------

// RolesResponse

// repeated string roles = 1;
inline int RolesResponse::roles_size() const {
  return roles_.size();
}
inline void RolesResponse::clear_roles() {
  roles_.Clear();
}
inline const ::std::string& RolesResponse::roles(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RolesResponse.roles)
  return roles_.Get(index);
}
inline ::std::string* RolesResponse::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RolesResponse.roles)
  return roles_.Mutable(index);
}
inline void RolesResponse::set_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.RolesResponse.roles)
  roles_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RolesResponse::set_roles(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.RolesResponse.roles)
  roles_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RolesResponse::set_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.RolesResponse.roles)
}
inline void RolesResponse::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.RolesResponse.roles)
}
inline ::std::string* RolesResponse::add_roles() {
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.RolesResponse.roles)
  return roles_.Add();
}
inline void RolesResponse::add_roles(const ::std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.RolesResponse.roles)
}
#if LANG_CXX11
inline void RolesResponse::add_roles(::std::string&& value) {
  roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.RolesResponse.roles)
}
#endif
inline void RolesResponse::add_roles(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.RolesResponse.roles)
}
inline void RolesResponse::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.RolesResponse.roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RolesResponse::roles() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.RolesResponse.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RolesResponse::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.RolesResponse.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// RolePermissionsResponse

// repeated string permissions = 1;
inline int RolePermissionsResponse::permissions_size() const {
  return permissions_.size();
}
inline void RolePermissionsResponse::clear_permissions() {
  permissions_.Clear();
}
inline const ::std::string& RolePermissionsResponse::permissions(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RolePermissionsResponse.permissions)
  return permissions_.Get(index);
}
inline ::std::string* RolePermissionsResponse::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RolePermissionsResponse.permissions)
  return permissions_.Mutable(index);
}
inline void RolePermissionsResponse::set_permissions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.RolePermissionsResponse.permissions)
  permissions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RolePermissionsResponse::set_permissions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.RolePermissionsResponse.permissions)
  permissions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RolePermissionsResponse::set_permissions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.RolePermissionsResponse.permissions)
}
inline void RolePermissionsResponse::set_permissions(int index, const char* value, size_t size) {
  permissions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.RolePermissionsResponse.permissions)
}
inline ::std::string* RolePermissionsResponse::add_permissions() {
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.RolePermissionsResponse.permissions)
  return permissions_.Add();
}
inline void RolePermissionsResponse::add_permissions(const ::std::string& value) {
  permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.RolePermissionsResponse.permissions)
}
#if LANG_CXX11
inline void RolePermissionsResponse::add_permissions(::std::string&& value) {
  permissions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.RolePermissionsResponse.permissions)
}
#endif
inline void RolePermissionsResponse::add_permissions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.RolePermissionsResponse.permissions)
}
inline void RolePermissionsResponse::add_permissions(const char* value, size_t size) {
  permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.RolePermissionsResponse.permissions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RolePermissionsResponse::permissions() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.RolePermissionsResponse.permissions)
  return permissions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RolePermissionsResponse::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.RolePermissionsResponse.permissions)
  return &permissions_;
}

// -------------------------------------------------------------------

// ErrorResponse

// .iroha.protocol.ErrorResponse.Reason reason = 1;
inline void ErrorResponse::clear_reason() {
  reason_ = 0;
}
inline ::iroha::protocol::ErrorResponse_Reason ErrorResponse::reason() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.ErrorResponse.reason)
  return static_cast< ::iroha::protocol::ErrorResponse_Reason >(reason_);
}
inline void ErrorResponse::set_reason(::iroha::protocol::ErrorResponse_Reason value) {
  
  reason_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.ErrorResponse.reason)
}

// -------------------------------------------------------------------

// SignatoriesResponse

// repeated bytes keys = 1;
inline int SignatoriesResponse::keys_size() const {
  return keys_.size();
}
inline void SignatoriesResponse::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& SignatoriesResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SignatoriesResponse.keys)
  return keys_.Get(index);
}
inline ::std::string* SignatoriesResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SignatoriesResponse.keys)
  return keys_.Mutable(index);
}
inline void SignatoriesResponse::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.SignatoriesResponse.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SignatoriesResponse::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.SignatoriesResponse.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SignatoriesResponse::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.SignatoriesResponse.keys)
}
inline void SignatoriesResponse::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.SignatoriesResponse.keys)
}
inline ::std::string* SignatoriesResponse::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.SignatoriesResponse.keys)
  return keys_.Add();
}
inline void SignatoriesResponse::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.SignatoriesResponse.keys)
}
#if LANG_CXX11
inline void SignatoriesResponse::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.SignatoriesResponse.keys)
}
#endif
inline void SignatoriesResponse::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.SignatoriesResponse.keys)
}
inline void SignatoriesResponse::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.SignatoriesResponse.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SignatoriesResponse::keys() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.SignatoriesResponse.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SignatoriesResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.SignatoriesResponse.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// TransactionsResponse

// repeated .iroha.protocol.Transaction transactions = 1;
inline int TransactionsResponse::transactions_size() const {
  return transactions_.size();
}
inline void TransactionsResponse::clear_transactions() {
  transactions_.Clear();
}
inline const ::iroha::protocol::Transaction& TransactionsResponse::transactions(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransactionsResponse.transactions)
  return transactions_.Get(index);
}
inline ::iroha::protocol::Transaction* TransactionsResponse::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransactionsResponse.transactions)
  return transactions_.Mutable(index);
}
inline ::iroha::protocol::Transaction* TransactionsResponse::add_transactions() {
  // @@protoc_insertion_point(field_add:iroha.protocol.TransactionsResponse.transactions)
  return transactions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::iroha::protocol::Transaction >*
TransactionsResponse::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.TransactionsResponse.transactions)
  return &transactions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::iroha::protocol::Transaction >&
TransactionsResponse::transactions() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.TransactionsResponse.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// QueryResponse

// .iroha.protocol.AccountAssetResponse account_assets_response = 1;
inline bool QueryResponse::has_account_assets_response() const {
  return response_case() == kAccountAssetsResponse;
}
inline void QueryResponse::set_has_account_assets_response() {
  _oneof_case_[0] = kAccountAssetsResponse;
}
inline void QueryResponse::clear_account_assets_response() {
  if (has_account_assets_response()) {
    delete response_.account_assets_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::AccountAssetResponse& QueryResponse::account_assets_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.account_assets_response)
  return has_account_assets_response()
      ? *response_.account_assets_response_
      : ::iroha::protocol::AccountAssetResponse::default_instance();
}
inline ::iroha::protocol::AccountAssetResponse* QueryResponse::mutable_account_assets_response() {
  if (!has_account_assets_response()) {
    clear_response();
    set_has_account_assets_response();
    response_.account_assets_response_ = new ::iroha::protocol::AccountAssetResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.account_assets_response)
  return response_.account_assets_response_;
}
inline ::iroha::protocol::AccountAssetResponse* QueryResponse::release_account_assets_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.account_assets_response)
  if (has_account_assets_response()) {
    clear_has_response();
    ::iroha::protocol::AccountAssetResponse* temp = response_.account_assets_response_;
    response_.account_assets_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_account_assets_response(::iroha::protocol::AccountAssetResponse* account_assets_response) {
  clear_response();
  if (account_assets_response) {
    set_has_account_assets_response();
    response_.account_assets_response_ = account_assets_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.account_assets_response)
}

// .iroha.protocol.AccountDetailResponse account_detail_response = 2;
inline bool QueryResponse::has_account_detail_response() const {
  return response_case() == kAccountDetailResponse;
}
inline void QueryResponse::set_has_account_detail_response() {
  _oneof_case_[0] = kAccountDetailResponse;
}
inline void QueryResponse::clear_account_detail_response() {
  if (has_account_detail_response()) {
    delete response_.account_detail_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::AccountDetailResponse& QueryResponse::account_detail_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.account_detail_response)
  return has_account_detail_response()
      ? *response_.account_detail_response_
      : ::iroha::protocol::AccountDetailResponse::default_instance();
}
inline ::iroha::protocol::AccountDetailResponse* QueryResponse::mutable_account_detail_response() {
  if (!has_account_detail_response()) {
    clear_response();
    set_has_account_detail_response();
    response_.account_detail_response_ = new ::iroha::protocol::AccountDetailResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.account_detail_response)
  return response_.account_detail_response_;
}
inline ::iroha::protocol::AccountDetailResponse* QueryResponse::release_account_detail_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.account_detail_response)
  if (has_account_detail_response()) {
    clear_has_response();
    ::iroha::protocol::AccountDetailResponse* temp = response_.account_detail_response_;
    response_.account_detail_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_account_detail_response(::iroha::protocol::AccountDetailResponse* account_detail_response) {
  clear_response();
  if (account_detail_response) {
    set_has_account_detail_response();
    response_.account_detail_response_ = account_detail_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.account_detail_response)
}

// .iroha.protocol.AccountResponse account_response = 3;
inline bool QueryResponse::has_account_response() const {
  return response_case() == kAccountResponse;
}
inline void QueryResponse::set_has_account_response() {
  _oneof_case_[0] = kAccountResponse;
}
inline void QueryResponse::clear_account_response() {
  if (has_account_response()) {
    delete response_.account_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::AccountResponse& QueryResponse::account_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.account_response)
  return has_account_response()
      ? *response_.account_response_
      : ::iroha::protocol::AccountResponse::default_instance();
}
inline ::iroha::protocol::AccountResponse* QueryResponse::mutable_account_response() {
  if (!has_account_response()) {
    clear_response();
    set_has_account_response();
    response_.account_response_ = new ::iroha::protocol::AccountResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.account_response)
  return response_.account_response_;
}
inline ::iroha::protocol::AccountResponse* QueryResponse::release_account_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.account_response)
  if (has_account_response()) {
    clear_has_response();
    ::iroha::protocol::AccountResponse* temp = response_.account_response_;
    response_.account_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_account_response(::iroha::protocol::AccountResponse* account_response) {
  clear_response();
  if (account_response) {
    set_has_account_response();
    response_.account_response_ = account_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.account_response)
}

// .iroha.protocol.ErrorResponse error_response = 4;
inline bool QueryResponse::has_error_response() const {
  return response_case() == kErrorResponse;
}
inline void QueryResponse::set_has_error_response() {
  _oneof_case_[0] = kErrorResponse;
}
inline void QueryResponse::clear_error_response() {
  if (has_error_response()) {
    delete response_.error_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::ErrorResponse& QueryResponse::error_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.error_response)
  return has_error_response()
      ? *response_.error_response_
      : ::iroha::protocol::ErrorResponse::default_instance();
}
inline ::iroha::protocol::ErrorResponse* QueryResponse::mutable_error_response() {
  if (!has_error_response()) {
    clear_response();
    set_has_error_response();
    response_.error_response_ = new ::iroha::protocol::ErrorResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.error_response)
  return response_.error_response_;
}
inline ::iroha::protocol::ErrorResponse* QueryResponse::release_error_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.error_response)
  if (has_error_response()) {
    clear_has_response();
    ::iroha::protocol::ErrorResponse* temp = response_.error_response_;
    response_.error_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_error_response(::iroha::protocol::ErrorResponse* error_response) {
  clear_response();
  if (error_response) {
    set_has_error_response();
    response_.error_response_ = error_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.error_response)
}

// .iroha.protocol.SignatoriesResponse signatories_response = 5;
inline bool QueryResponse::has_signatories_response() const {
  return response_case() == kSignatoriesResponse;
}
inline void QueryResponse::set_has_signatories_response() {
  _oneof_case_[0] = kSignatoriesResponse;
}
inline void QueryResponse::clear_signatories_response() {
  if (has_signatories_response()) {
    delete response_.signatories_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::SignatoriesResponse& QueryResponse::signatories_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.signatories_response)
  return has_signatories_response()
      ? *response_.signatories_response_
      : ::iroha::protocol::SignatoriesResponse::default_instance();
}
inline ::iroha::protocol::SignatoriesResponse* QueryResponse::mutable_signatories_response() {
  if (!has_signatories_response()) {
    clear_response();
    set_has_signatories_response();
    response_.signatories_response_ = new ::iroha::protocol::SignatoriesResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.signatories_response)
  return response_.signatories_response_;
}
inline ::iroha::protocol::SignatoriesResponse* QueryResponse::release_signatories_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.signatories_response)
  if (has_signatories_response()) {
    clear_has_response();
    ::iroha::protocol::SignatoriesResponse* temp = response_.signatories_response_;
    response_.signatories_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_signatories_response(::iroha::protocol::SignatoriesResponse* signatories_response) {
  clear_response();
  if (signatories_response) {
    set_has_signatories_response();
    response_.signatories_response_ = signatories_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.signatories_response)
}

// .iroha.protocol.TransactionsResponse transactions_response = 6;
inline bool QueryResponse::has_transactions_response() const {
  return response_case() == kTransactionsResponse;
}
inline void QueryResponse::set_has_transactions_response() {
  _oneof_case_[0] = kTransactionsResponse;
}
inline void QueryResponse::clear_transactions_response() {
  if (has_transactions_response()) {
    delete response_.transactions_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::TransactionsResponse& QueryResponse::transactions_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.transactions_response)
  return has_transactions_response()
      ? *response_.transactions_response_
      : ::iroha::protocol::TransactionsResponse::default_instance();
}
inline ::iroha::protocol::TransactionsResponse* QueryResponse::mutable_transactions_response() {
  if (!has_transactions_response()) {
    clear_response();
    set_has_transactions_response();
    response_.transactions_response_ = new ::iroha::protocol::TransactionsResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.transactions_response)
  return response_.transactions_response_;
}
inline ::iroha::protocol::TransactionsResponse* QueryResponse::release_transactions_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.transactions_response)
  if (has_transactions_response()) {
    clear_has_response();
    ::iroha::protocol::TransactionsResponse* temp = response_.transactions_response_;
    response_.transactions_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_transactions_response(::iroha::protocol::TransactionsResponse* transactions_response) {
  clear_response();
  if (transactions_response) {
    set_has_transactions_response();
    response_.transactions_response_ = transactions_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.transactions_response)
}

// .iroha.protocol.AssetResponse asset_response = 7;
inline bool QueryResponse::has_asset_response() const {
  return response_case() == kAssetResponse;
}
inline void QueryResponse::set_has_asset_response() {
  _oneof_case_[0] = kAssetResponse;
}
inline void QueryResponse::clear_asset_response() {
  if (has_asset_response()) {
    delete response_.asset_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::AssetResponse& QueryResponse::asset_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.asset_response)
  return has_asset_response()
      ? *response_.asset_response_
      : ::iroha::protocol::AssetResponse::default_instance();
}
inline ::iroha::protocol::AssetResponse* QueryResponse::mutable_asset_response() {
  if (!has_asset_response()) {
    clear_response();
    set_has_asset_response();
    response_.asset_response_ = new ::iroha::protocol::AssetResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.asset_response)
  return response_.asset_response_;
}
inline ::iroha::protocol::AssetResponse* QueryResponse::release_asset_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.asset_response)
  if (has_asset_response()) {
    clear_has_response();
    ::iroha::protocol::AssetResponse* temp = response_.asset_response_;
    response_.asset_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_asset_response(::iroha::protocol::AssetResponse* asset_response) {
  clear_response();
  if (asset_response) {
    set_has_asset_response();
    response_.asset_response_ = asset_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.asset_response)
}

// .iroha.protocol.RolesResponse roles_response = 8;
inline bool QueryResponse::has_roles_response() const {
  return response_case() == kRolesResponse;
}
inline void QueryResponse::set_has_roles_response() {
  _oneof_case_[0] = kRolesResponse;
}
inline void QueryResponse::clear_roles_response() {
  if (has_roles_response()) {
    delete response_.roles_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::RolesResponse& QueryResponse::roles_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.roles_response)
  return has_roles_response()
      ? *response_.roles_response_
      : ::iroha::protocol::RolesResponse::default_instance();
}
inline ::iroha::protocol::RolesResponse* QueryResponse::mutable_roles_response() {
  if (!has_roles_response()) {
    clear_response();
    set_has_roles_response();
    response_.roles_response_ = new ::iroha::protocol::RolesResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.roles_response)
  return response_.roles_response_;
}
inline ::iroha::protocol::RolesResponse* QueryResponse::release_roles_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.roles_response)
  if (has_roles_response()) {
    clear_has_response();
    ::iroha::protocol::RolesResponse* temp = response_.roles_response_;
    response_.roles_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_roles_response(::iroha::protocol::RolesResponse* roles_response) {
  clear_response();
  if (roles_response) {
    set_has_roles_response();
    response_.roles_response_ = roles_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.roles_response)
}

// .iroha.protocol.RolePermissionsResponse role_permissions_response = 9;
inline bool QueryResponse::has_role_permissions_response() const {
  return response_case() == kRolePermissionsResponse;
}
inline void QueryResponse::set_has_role_permissions_response() {
  _oneof_case_[0] = kRolePermissionsResponse;
}
inline void QueryResponse::clear_role_permissions_response() {
  if (has_role_permissions_response()) {
    delete response_.role_permissions_response_;
    clear_has_response();
  }
}
inline  const ::iroha::protocol::RolePermissionsResponse& QueryResponse::role_permissions_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.role_permissions_response)
  return has_role_permissions_response()
      ? *response_.role_permissions_response_
      : ::iroha::protocol::RolePermissionsResponse::default_instance();
}
inline ::iroha::protocol::RolePermissionsResponse* QueryResponse::mutable_role_permissions_response() {
  if (!has_role_permissions_response()) {
    clear_response();
    set_has_role_permissions_response();
    response_.role_permissions_response_ = new ::iroha::protocol::RolePermissionsResponse;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.role_permissions_response)
  return response_.role_permissions_response_;
}
inline ::iroha::protocol::RolePermissionsResponse* QueryResponse::release_role_permissions_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.role_permissions_response)
  if (has_role_permissions_response()) {
    clear_has_response();
    ::iroha::protocol::RolePermissionsResponse* temp = response_.role_permissions_response_;
    response_.role_permissions_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void QueryResponse::set_allocated_role_permissions_response(::iroha::protocol::RolePermissionsResponse* role_permissions_response) {
  clear_response();
  if (role_permissions_response) {
    set_has_role_permissions_response();
    response_.role_permissions_response_ = role_permissions_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.role_permissions_response)
}

// bytes query_hash = 10;
inline void QueryResponse::clear_query_hash() {
  query_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QueryResponse::query_hash() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.query_hash)
  return query_hash_.GetNoArena();
}
inline void QueryResponse::set_query_hash(const ::std::string& value) {
  
  query_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.QueryResponse.query_hash)
}
#if LANG_CXX11
inline void QueryResponse::set_query_hash(::std::string&& value) {
  
  query_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.QueryResponse.query_hash)
}
#endif
inline void QueryResponse::set_query_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  query_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.QueryResponse.query_hash)
}
inline void QueryResponse::set_query_hash(const void* value, size_t size) {
  
  query_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.QueryResponse.query_hash)
}
inline ::std::string* QueryResponse::mutable_query_hash() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.query_hash)
  return query_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryResponse::release_query_hash() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.query_hash)
  
  return query_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryResponse::set_allocated_query_hash(::std::string* query_hash) {
  if (query_hash != NULL) {
    
  } else {
    
  }
  query_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query_hash);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.query_hash)
}

inline bool QueryResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void QueryResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline QueryResponse::ResponseCase QueryResponse::response_case() const {
  return QueryResponse::ResponseCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protocol
}  // namespace iroha

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::iroha::protocol::ErrorResponse_Reason> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iroha::protocol::ErrorResponse_Reason>() {
  return ::iroha::protocol::ErrorResponse_Reason_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_responses_2eproto__INCLUDED
