// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: queries.proto

#ifndef PROTOBUF_queries_2eproto__INCLUDED
#define PROTOBUF_queries_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "primitive.pb.h"
// @@protoc_insertion_point(includes)
namespace iroha {
namespace protocol {
class GetAccount;
class GetAccountDefaultTypeInternal;
extern GetAccountDefaultTypeInternal _GetAccount_default_instance_;
class GetAccountAssetTransactions;
class GetAccountAssetTransactionsDefaultTypeInternal;
extern GetAccountAssetTransactionsDefaultTypeInternal _GetAccountAssetTransactions_default_instance_;
class GetAccountAssets;
class GetAccountAssetsDefaultTypeInternal;
extern GetAccountAssetsDefaultTypeInternal _GetAccountAssets_default_instance_;
class GetAccountDetail;
class GetAccountDetailDefaultTypeInternal;
extern GetAccountDetailDefaultTypeInternal _GetAccountDetail_default_instance_;
class GetAccountTransactions;
class GetAccountTransactionsDefaultTypeInternal;
extern GetAccountTransactionsDefaultTypeInternal _GetAccountTransactions_default_instance_;
class GetAssetInfo;
class GetAssetInfoDefaultTypeInternal;
extern GetAssetInfoDefaultTypeInternal _GetAssetInfo_default_instance_;
class GetRolePermissions;
class GetRolePermissionsDefaultTypeInternal;
extern GetRolePermissionsDefaultTypeInternal _GetRolePermissions_default_instance_;
class GetRoles;
class GetRolesDefaultTypeInternal;
extern GetRolesDefaultTypeInternal _GetRoles_default_instance_;
class GetSignatories;
class GetSignatoriesDefaultTypeInternal;
extern GetSignatoriesDefaultTypeInternal _GetSignatories_default_instance_;
class GetTransactions;
class GetTransactionsDefaultTypeInternal;
extern GetTransactionsDefaultTypeInternal _GetTransactions_default_instance_;
class Query;
class QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class Query_Payload;
class Query_PayloadDefaultTypeInternal;
extern Query_PayloadDefaultTypeInternal _Query_Payload_default_instance_;
}  // namespace protocol
}  // namespace iroha

namespace iroha {
namespace protocol {

namespace protobuf_queries_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_queries_2eproto

// ===================================================================

class GetAccount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccount) */ {
 public:
  GetAccount();
  virtual ~GetAccount();

  GetAccount(const GetAccount& from);

  inline GetAccount& operator=(const GetAccount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccount(GetAccount&& from) noexcept
    : GetAccount() {
    *this = ::std::move(from);
  }

  inline GetAccount& operator=(GetAccount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccount& default_instance();

  static inline const GetAccount* internal_default_instance() {
    return reinterpret_cast<const GetAccount*>(
               &_GetAccount_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GetAccount* other);
  friend void swap(GetAccount& a, GetAccount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccount* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAccount* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAccount& from);
  void MergeFrom(const GetAccount& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAccount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSignatories : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetSignatories) */ {
 public:
  GetSignatories();
  virtual ~GetSignatories();

  GetSignatories(const GetSignatories& from);

  inline GetSignatories& operator=(const GetSignatories& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSignatories(GetSignatories&& from) noexcept
    : GetSignatories() {
    *this = ::std::move(from);
  }

  inline GetSignatories& operator=(GetSignatories&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSignatories& default_instance();

  static inline const GetSignatories* internal_default_instance() {
    return reinterpret_cast<const GetSignatories*>(
               &_GetSignatories_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GetSignatories* other);
  friend void swap(GetSignatories& a, GetSignatories& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSignatories* New() const PROTOBUF_FINAL { return New(NULL); }

  GetSignatories* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetSignatories& from);
  void MergeFrom(const GetSignatories& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetSignatories* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetSignatories)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAccountTransactions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccountTransactions) */ {
 public:
  GetAccountTransactions();
  virtual ~GetAccountTransactions();

  GetAccountTransactions(const GetAccountTransactions& from);

  inline GetAccountTransactions& operator=(const GetAccountTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountTransactions(GetAccountTransactions&& from) noexcept
    : GetAccountTransactions() {
    *this = ::std::move(from);
  }

  inline GetAccountTransactions& operator=(GetAccountTransactions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccountTransactions& default_instance();

  static inline const GetAccountTransactions* internal_default_instance() {
    return reinterpret_cast<const GetAccountTransactions*>(
               &_GetAccountTransactions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GetAccountTransactions* other);
  friend void swap(GetAccountTransactions& a, GetAccountTransactions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountTransactions* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAccountTransactions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAccountTransactions& from);
  void MergeFrom(const GetAccountTransactions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAccountTransactions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccountTransactions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAccountAssetTransactions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccountAssetTransactions) */ {
 public:
  GetAccountAssetTransactions();
  virtual ~GetAccountAssetTransactions();

  GetAccountAssetTransactions(const GetAccountAssetTransactions& from);

  inline GetAccountAssetTransactions& operator=(const GetAccountAssetTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountAssetTransactions(GetAccountAssetTransactions&& from) noexcept
    : GetAccountAssetTransactions() {
    *this = ::std::move(from);
  }

  inline GetAccountAssetTransactions& operator=(GetAccountAssetTransactions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccountAssetTransactions& default_instance();

  static inline const GetAccountAssetTransactions* internal_default_instance() {
    return reinterpret_cast<const GetAccountAssetTransactions*>(
               &_GetAccountAssetTransactions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GetAccountAssetTransactions* other);
  friend void swap(GetAccountAssetTransactions& a, GetAccountAssetTransactions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAssetTransactions* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAccountAssetTransactions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAccountAssetTransactions& from);
  void MergeFrom(const GetAccountAssetTransactions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAccountAssetTransactions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // string asset_id = 2;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 2;
  const ::std::string& asset_id() const;
  void set_asset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_id(::std::string&& value);
  #endif
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  ::std::string* mutable_asset_id();
  ::std::string* release_asset_id();
  void set_allocated_asset_id(::std::string* asset_id);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccountAssetTransactions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr asset_id_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTransactions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetTransactions) */ {
 public:
  GetTransactions();
  virtual ~GetTransactions();

  GetTransactions(const GetTransactions& from);

  inline GetTransactions& operator=(const GetTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTransactions(GetTransactions&& from) noexcept
    : GetTransactions() {
    *this = ::std::move(from);
  }

  inline GetTransactions& operator=(GetTransactions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTransactions& default_instance();

  static inline const GetTransactions* internal_default_instance() {
    return reinterpret_cast<const GetTransactions*>(
               &_GetTransactions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(GetTransactions* other);
  friend void swap(GetTransactions& a, GetTransactions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTransactions* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTransactions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTransactions& from);
  void MergeFrom(const GetTransactions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTransactions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes tx_hashes = 1;
  int tx_hashes_size() const;
  void clear_tx_hashes();
  static const int kTxHashesFieldNumber = 1;
  const ::std::string& tx_hashes(int index) const;
  ::std::string* mutable_tx_hashes(int index);
  void set_tx_hashes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tx_hashes(int index, ::std::string&& value);
  #endif
  void set_tx_hashes(int index, const char* value);
  void set_tx_hashes(int index, const void* value, size_t size);
  ::std::string* add_tx_hashes();
  void add_tx_hashes(const ::std::string& value);
  #if LANG_CXX11
  void add_tx_hashes(::std::string&& value);
  #endif
  void add_tx_hashes(const char* value);
  void add_tx_hashes(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tx_hashes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tx_hashes();

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetTransactions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tx_hashes_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAccountAssets : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccountAssets) */ {
 public:
  GetAccountAssets();
  virtual ~GetAccountAssets();

  GetAccountAssets(const GetAccountAssets& from);

  inline GetAccountAssets& operator=(const GetAccountAssets& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountAssets(GetAccountAssets&& from) noexcept
    : GetAccountAssets() {
    *this = ::std::move(from);
  }

  inline GetAccountAssets& operator=(GetAccountAssets&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccountAssets& default_instance();

  static inline const GetAccountAssets* internal_default_instance() {
    return reinterpret_cast<const GetAccountAssets*>(
               &_GetAccountAssets_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GetAccountAssets* other);
  friend void swap(GetAccountAssets& a, GetAccountAssets& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAssets* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAccountAssets* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAccountAssets& from);
  void MergeFrom(const GetAccountAssets& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAccountAssets* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // string asset_id = 2;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 2;
  const ::std::string& asset_id() const;
  void set_asset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_id(::std::string&& value);
  #endif
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  ::std::string* mutable_asset_id();
  ::std::string* release_asset_id();
  void set_allocated_asset_id(::std::string* asset_id);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccountAssets)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  ::google::protobuf::internal::ArenaStringPtr asset_id_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAccountDetail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccountDetail) */ {
 public:
  GetAccountDetail();
  virtual ~GetAccountDetail();

  GetAccountDetail(const GetAccountDetail& from);

  inline GetAccountDetail& operator=(const GetAccountDetail& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountDetail(GetAccountDetail&& from) noexcept
    : GetAccountDetail() {
    *this = ::std::move(from);
  }

  inline GetAccountDetail& operator=(GetAccountDetail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccountDetail& default_instance();

  static inline const GetAccountDetail* internal_default_instance() {
    return reinterpret_cast<const GetAccountDetail*>(
               &_GetAccountDetail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(GetAccountDetail* other);
  friend void swap(GetAccountDetail& a, GetAccountDetail& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountDetail* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAccountDetail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAccountDetail& from);
  void MergeFrom(const GetAccountDetail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAccountDetail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  const ::std::string& account_id() const;
  void set_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_account_id(::std::string&& value);
  #endif
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  ::std::string* mutable_account_id();
  ::std::string* release_account_id();
  void set_allocated_account_id(::std::string* account_id);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccountDetail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_id_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAssetInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAssetInfo) */ {
 public:
  GetAssetInfo();
  virtual ~GetAssetInfo();

  GetAssetInfo(const GetAssetInfo& from);

  inline GetAssetInfo& operator=(const GetAssetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAssetInfo(GetAssetInfo&& from) noexcept
    : GetAssetInfo() {
    *this = ::std::move(from);
  }

  inline GetAssetInfo& operator=(GetAssetInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAssetInfo& default_instance();

  static inline const GetAssetInfo* internal_default_instance() {
    return reinterpret_cast<const GetAssetInfo*>(
               &_GetAssetInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GetAssetInfo* other);
  friend void swap(GetAssetInfo& a, GetAssetInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAssetInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAssetInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAssetInfo& from);
  void MergeFrom(const GetAssetInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAssetInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string asset_id = 1;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 1;
  const ::std::string& asset_id() const;
  void set_asset_id(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_id(::std::string&& value);
  #endif
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  ::std::string* mutable_asset_id();
  ::std::string* release_asset_id();
  void set_allocated_asset_id(::std::string* asset_id);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAssetInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asset_id_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRoles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetRoles) */ {
 public:
  GetRoles();
  virtual ~GetRoles();

  GetRoles(const GetRoles& from);

  inline GetRoles& operator=(const GetRoles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRoles(GetRoles&& from) noexcept
    : GetRoles() {
    *this = ::std::move(from);
  }

  inline GetRoles& operator=(GetRoles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoles& default_instance();

  static inline const GetRoles* internal_default_instance() {
    return reinterpret_cast<const GetRoles*>(
               &_GetRoles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GetRoles* other);
  friend void swap(GetRoles& a, GetRoles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRoles* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRoles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRoles& from);
  void MergeFrom(const GetRoles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRoles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetRoles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRolePermissions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetRolePermissions) */ {
 public:
  GetRolePermissions();
  virtual ~GetRolePermissions();

  GetRolePermissions(const GetRolePermissions& from);

  inline GetRolePermissions& operator=(const GetRolePermissions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRolePermissions(GetRolePermissions&& from) noexcept
    : GetRolePermissions() {
    *this = ::std::move(from);
  }

  inline GetRolePermissions& operator=(GetRolePermissions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRolePermissions& default_instance();

  static inline const GetRolePermissions* internal_default_instance() {
    return reinterpret_cast<const GetRolePermissions*>(
               &_GetRolePermissions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(GetRolePermissions* other);
  friend void swap(GetRolePermissions& a, GetRolePermissions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRolePermissions* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRolePermissions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRolePermissions& from);
  void MergeFrom(const GetRolePermissions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRolePermissions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string role_id = 1;
  void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  const ::std::string& role_id() const;
  void set_role_id(const ::std::string& value);
  #if LANG_CXX11
  void set_role_id(::std::string&& value);
  #endif
  void set_role_id(const char* value);
  void set_role_id(const char* value, size_t size);
  ::std::string* mutable_role_id();
  ::std::string* release_role_id();
  void set_allocated_role_id(::std::string* role_id);

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetRolePermissions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr role_id_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Query_Payload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Query.Payload) */ {
 public:
  Query_Payload();
  virtual ~Query_Payload();

  Query_Payload(const Query_Payload& from);

  inline Query_Payload& operator=(const Query_Payload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Query_Payload(Query_Payload&& from) noexcept
    : Query_Payload() {
    *this = ::std::move(from);
  }

  inline Query_Payload& operator=(Query_Payload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query_Payload& default_instance();

  enum QueryCase {
    kGetAccount = 3,
    kGetAccountSignatories = 4,
    kGetAccountTransactions = 5,
    kGetAccountAssetTransactions = 6,
    kGetTransactions = 7,
    kGetAccountAssets = 8,
    kGetAccountDetail = 9,
    kGetRoles = 10,
    kGetRolePermissions = 11,
    kGetAssetInfo = 12,
    QUERY_NOT_SET = 0,
  };

  static inline const Query_Payload* internal_default_instance() {
    return reinterpret_cast<const Query_Payload*>(
               &_Query_Payload_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Query_Payload* other);
  friend void swap(Query_Payload& a, Query_Payload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Query_Payload* New() const PROTOBUF_FINAL { return New(NULL); }

  Query_Payload* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Query_Payload& from);
  void MergeFrom(const Query_Payload& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Query_Payload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string creator_account_id = 2;
  void clear_creator_account_id();
  static const int kCreatorAccountIdFieldNumber = 2;
  const ::std::string& creator_account_id() const;
  void set_creator_account_id(const ::std::string& value);
  #if LANG_CXX11
  void set_creator_account_id(::std::string&& value);
  #endif
  void set_creator_account_id(const char* value);
  void set_creator_account_id(const char* value, size_t size);
  ::std::string* mutable_creator_account_id();
  ::std::string* release_creator_account_id();
  void set_allocated_creator_account_id(::std::string* creator_account_id);

  // uint64 created_time = 1;
  void clear_created_time();
  static const int kCreatedTimeFieldNumber = 1;
  ::google::protobuf::uint64 created_time() const;
  void set_created_time(::google::protobuf::uint64 value);

  // uint64 query_counter = 13;
  void clear_query_counter();
  static const int kQueryCounterFieldNumber = 13;
  ::google::protobuf::uint64 query_counter() const;
  void set_query_counter(::google::protobuf::uint64 value);

  // .iroha.protocol.GetAccount get_account = 3;
  bool has_get_account() const;
  void clear_get_account();
  static const int kGetAccountFieldNumber = 3;
  const ::iroha::protocol::GetAccount& get_account() const;
  ::iroha::protocol::GetAccount* mutable_get_account();
  ::iroha::protocol::GetAccount* release_get_account();
  void set_allocated_get_account(::iroha::protocol::GetAccount* get_account);

  // .iroha.protocol.GetSignatories get_account_signatories = 4;
  bool has_get_account_signatories() const;
  void clear_get_account_signatories();
  static const int kGetAccountSignatoriesFieldNumber = 4;
  const ::iroha::protocol::GetSignatories& get_account_signatories() const;
  ::iroha::protocol::GetSignatories* mutable_get_account_signatories();
  ::iroha::protocol::GetSignatories* release_get_account_signatories();
  void set_allocated_get_account_signatories(::iroha::protocol::GetSignatories* get_account_signatories);

  // .iroha.protocol.GetAccountTransactions get_account_transactions = 5;
  bool has_get_account_transactions() const;
  void clear_get_account_transactions();
  static const int kGetAccountTransactionsFieldNumber = 5;
  const ::iroha::protocol::GetAccountTransactions& get_account_transactions() const;
  ::iroha::protocol::GetAccountTransactions* mutable_get_account_transactions();
  ::iroha::protocol::GetAccountTransactions* release_get_account_transactions();
  void set_allocated_get_account_transactions(::iroha::protocol::GetAccountTransactions* get_account_transactions);

  // .iroha.protocol.GetAccountAssetTransactions get_account_asset_transactions = 6;
  bool has_get_account_asset_transactions() const;
  void clear_get_account_asset_transactions();
  static const int kGetAccountAssetTransactionsFieldNumber = 6;
  const ::iroha::protocol::GetAccountAssetTransactions& get_account_asset_transactions() const;
  ::iroha::protocol::GetAccountAssetTransactions* mutable_get_account_asset_transactions();
  ::iroha::protocol::GetAccountAssetTransactions* release_get_account_asset_transactions();
  void set_allocated_get_account_asset_transactions(::iroha::protocol::GetAccountAssetTransactions* get_account_asset_transactions);

  // .iroha.protocol.GetTransactions get_transactions = 7;
  bool has_get_transactions() const;
  void clear_get_transactions();
  static const int kGetTransactionsFieldNumber = 7;
  const ::iroha::protocol::GetTransactions& get_transactions() const;
  ::iroha::protocol::GetTransactions* mutable_get_transactions();
  ::iroha::protocol::GetTransactions* release_get_transactions();
  void set_allocated_get_transactions(::iroha::protocol::GetTransactions* get_transactions);

  // .iroha.protocol.GetAccountAssets get_account_assets = 8;
  bool has_get_account_assets() const;
  void clear_get_account_assets();
  static const int kGetAccountAssetsFieldNumber = 8;
  const ::iroha::protocol::GetAccountAssets& get_account_assets() const;
  ::iroha::protocol::GetAccountAssets* mutable_get_account_assets();
  ::iroha::protocol::GetAccountAssets* release_get_account_assets();
  void set_allocated_get_account_assets(::iroha::protocol::GetAccountAssets* get_account_assets);

  // .iroha.protocol.GetAccountDetail get_account_detail = 9;
  bool has_get_account_detail() const;
  void clear_get_account_detail();
  static const int kGetAccountDetailFieldNumber = 9;
  const ::iroha::protocol::GetAccountDetail& get_account_detail() const;
  ::iroha::protocol::GetAccountDetail* mutable_get_account_detail();
  ::iroha::protocol::GetAccountDetail* release_get_account_detail();
  void set_allocated_get_account_detail(::iroha::protocol::GetAccountDetail* get_account_detail);

  // .iroha.protocol.GetRoles get_roles = 10;
  bool has_get_roles() const;
  void clear_get_roles();
  static const int kGetRolesFieldNumber = 10;
  const ::iroha::protocol::GetRoles& get_roles() const;
  ::iroha::protocol::GetRoles* mutable_get_roles();
  ::iroha::protocol::GetRoles* release_get_roles();
  void set_allocated_get_roles(::iroha::protocol::GetRoles* get_roles);

  // .iroha.protocol.GetRolePermissions get_role_permissions = 11;
  bool has_get_role_permissions() const;
  void clear_get_role_permissions();
  static const int kGetRolePermissionsFieldNumber = 11;
  const ::iroha::protocol::GetRolePermissions& get_role_permissions() const;
  ::iroha::protocol::GetRolePermissions* mutable_get_role_permissions();
  ::iroha::protocol::GetRolePermissions* release_get_role_permissions();
  void set_allocated_get_role_permissions(::iroha::protocol::GetRolePermissions* get_role_permissions);

  // .iroha.protocol.GetAssetInfo get_asset_info = 12;
  bool has_get_asset_info() const;
  void clear_get_asset_info();
  static const int kGetAssetInfoFieldNumber = 12;
  const ::iroha::protocol::GetAssetInfo& get_asset_info() const;
  ::iroha::protocol::GetAssetInfo* mutable_get_asset_info();
  ::iroha::protocol::GetAssetInfo* release_get_asset_info();
  void set_allocated_get_asset_info(::iroha::protocol::GetAssetInfo* get_asset_info);

  QueryCase query_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.Query.Payload)
 private:
  void set_has_get_account();
  void set_has_get_account_signatories();
  void set_has_get_account_transactions();
  void set_has_get_account_asset_transactions();
  void set_has_get_transactions();
  void set_has_get_account_assets();
  void set_has_get_account_detail();
  void set_has_get_roles();
  void set_has_get_role_permissions();
  void set_has_get_asset_info();

  inline bool has_query() const;
  void clear_query();
  inline void clear_has_query();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr creator_account_id_;
  ::google::protobuf::uint64 created_time_;
  ::google::protobuf::uint64 query_counter_;
  union QueryUnion {
    QueryUnion() {}
    ::iroha::protocol::GetAccount* get_account_;
    ::iroha::protocol::GetSignatories* get_account_signatories_;
    ::iroha::protocol::GetAccountTransactions* get_account_transactions_;
    ::iroha::protocol::GetAccountAssetTransactions* get_account_asset_transactions_;
    ::iroha::protocol::GetTransactions* get_transactions_;
    ::iroha::protocol::GetAccountAssets* get_account_assets_;
    ::iroha::protocol::GetAccountDetail* get_account_detail_;
    ::iroha::protocol::GetRoles* get_roles_;
    ::iroha::protocol::GetRolePermissions* get_role_permissions_;
    ::iroha::protocol::GetAssetInfo* get_asset_info_;
  } query_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_queries_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Query) */ {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Query* other);
  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Query* New() const PROTOBUF_FINAL { return New(NULL); }

  Query* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Query_Payload Payload;

  // accessors -------------------------------------------------------

  // .iroha.protocol.Query.Payload payload = 1;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::iroha::protocol::Query_Payload& payload() const;
  ::iroha::protocol::Query_Payload* mutable_payload();
  ::iroha::protocol::Query_Payload* release_payload();
  void set_allocated_payload(::iroha::protocol::Query_Payload* payload);

  // .iroha.protocol.Signature signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::iroha::protocol::Signature& signature() const;
  ::iroha::protocol::Signature* mutable_signature();
  ::iroha::protocol::Signature* release_signature();
  void set_allocated_signature(::iroha::protocol::Signature* signature);

  // @@protoc_insertion_point(class_scope:iroha.protocol.Query)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::iroha::protocol::Query_Payload* payload_;
  ::iroha::protocol::Signature* signature_;
  mutable int _cached_size_;
  friend struct protobuf_queries_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetAccount

// string account_id = 1;
inline void GetAccount::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccount::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccount.account_id)
  return account_id_.GetNoArena();
}
inline void GetAccount::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccount.account_id)
}
#if LANG_CXX11
inline void GetAccount::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetAccount.account_id)
}
#endif
inline void GetAccount::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetAccount.account_id)
}
inline void GetAccount::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetAccount.account_id)
}
inline ::std::string* GetAccount::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccount.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccount::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccount.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccount::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccount.account_id)
}

// -------------------------------------------------------------------

// GetSignatories

// string account_id = 1;
inline void GetSignatories::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSignatories::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetSignatories.account_id)
  return account_id_.GetNoArena();
}
inline void GetSignatories::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetSignatories.account_id)
}
#if LANG_CXX11
inline void GetSignatories::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetSignatories.account_id)
}
#endif
inline void GetSignatories::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetSignatories.account_id)
}
inline void GetSignatories::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetSignatories.account_id)
}
inline ::std::string* GetSignatories::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetSignatories.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSignatories::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetSignatories.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSignatories::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetSignatories.account_id)
}

// -------------------------------------------------------------------

// GetAccountTransactions

// string account_id = 1;
inline void GetAccountTransactions::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountTransactions::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountTransactions.account_id)
  return account_id_.GetNoArena();
}
inline void GetAccountTransactions::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountTransactions.account_id)
}
#if LANG_CXX11
inline void GetAccountTransactions::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetAccountTransactions.account_id)
}
#endif
inline void GetAccountTransactions::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetAccountTransactions.account_id)
}
inline void GetAccountTransactions::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetAccountTransactions.account_id)
}
inline ::std::string* GetAccountTransactions::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountTransactions.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountTransactions::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountTransactions.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountTransactions::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountTransactions.account_id)
}

// -------------------------------------------------------------------

// GetAccountAssetTransactions

// string account_id = 1;
inline void GetAccountAssetTransactions::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountAssetTransactions::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssetTransactions.account_id)
  return account_id_.GetNoArena();
}
inline void GetAccountAssetTransactions::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountAssetTransactions.account_id)
}
#if LANG_CXX11
inline void GetAccountAssetTransactions::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetAccountAssetTransactions.account_id)
}
#endif
inline void GetAccountAssetTransactions::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetAccountAssetTransactions.account_id)
}
inline void GetAccountAssetTransactions::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetAccountAssetTransactions.account_id)
}
inline ::std::string* GetAccountAssetTransactions::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssetTransactions.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountAssetTransactions::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssetTransactions.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountAssetTransactions::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssetTransactions.account_id)
}

// string asset_id = 2;
inline void GetAccountAssetTransactions::clear_asset_id() {
  asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountAssetTransactions::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssetTransactions.asset_id)
  return asset_id_.GetNoArena();
}
inline void GetAccountAssetTransactions::set_asset_id(const ::std::string& value) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountAssetTransactions.asset_id)
}
#if LANG_CXX11
inline void GetAccountAssetTransactions::set_asset_id(::std::string&& value) {
  
  asset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetAccountAssetTransactions.asset_id)
}
#endif
inline void GetAccountAssetTransactions::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetAccountAssetTransactions.asset_id)
}
inline void GetAccountAssetTransactions::set_asset_id(const char* value, size_t size) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetAccountAssetTransactions.asset_id)
}
inline ::std::string* GetAccountAssetTransactions::mutable_asset_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssetTransactions.asset_id)
  return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountAssetTransactions::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssetTransactions.asset_id)
  
  return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountAssetTransactions::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id != NULL) {
    
  } else {
    
  }
  asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssetTransactions.asset_id)
}

// -------------------------------------------------------------------

// GetTransactions

// repeated bytes tx_hashes = 1;
inline int GetTransactions::tx_hashes_size() const {
  return tx_hashes_.size();
}
inline void GetTransactions::clear_tx_hashes() {
  tx_hashes_.Clear();
}
inline const ::std::string& GetTransactions::tx_hashes(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetTransactions.tx_hashes)
  return tx_hashes_.Get(index);
}
inline ::std::string* GetTransactions::mutable_tx_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetTransactions.tx_hashes)
  return tx_hashes_.Mutable(index);
}
inline void GetTransactions::set_tx_hashes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.GetTransactions.tx_hashes)
  tx_hashes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetTransactions::set_tx_hashes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.GetTransactions.tx_hashes)
  tx_hashes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetTransactions::set_tx_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tx_hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetTransactions.tx_hashes)
}
inline void GetTransactions::set_tx_hashes(int index, const void* value, size_t size) {
  tx_hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetTransactions.tx_hashes)
}
inline ::std::string* GetTransactions::add_tx_hashes() {
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.GetTransactions.tx_hashes)
  return tx_hashes_.Add();
}
inline void GetTransactions::add_tx_hashes(const ::std::string& value) {
  tx_hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.GetTransactions.tx_hashes)
}
#if LANG_CXX11
inline void GetTransactions::add_tx_hashes(::std::string&& value) {
  tx_hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.GetTransactions.tx_hashes)
}
#endif
inline void GetTransactions::add_tx_hashes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tx_hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.GetTransactions.tx_hashes)
}
inline void GetTransactions::add_tx_hashes(const void* value, size_t size) {
  tx_hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.GetTransactions.tx_hashes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTransactions::tx_hashes() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.GetTransactions.tx_hashes)
  return tx_hashes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTransactions::mutable_tx_hashes() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.GetTransactions.tx_hashes)
  return &tx_hashes_;
}

// -------------------------------------------------------------------

// GetAccountAssets

// string account_id = 1;
inline void GetAccountAssets::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountAssets::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssets.account_id)
  return account_id_.GetNoArena();
}
inline void GetAccountAssets::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountAssets.account_id)
}
#if LANG_CXX11
inline void GetAccountAssets::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetAccountAssets.account_id)
}
#endif
inline void GetAccountAssets::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetAccountAssets.account_id)
}
inline void GetAccountAssets::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetAccountAssets.account_id)
}
inline ::std::string* GetAccountAssets::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssets.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountAssets::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssets.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountAssets::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssets.account_id)
}

// string asset_id = 2;
inline void GetAccountAssets::clear_asset_id() {
  asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountAssets::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssets.asset_id)
  return asset_id_.GetNoArena();
}
inline void GetAccountAssets::set_asset_id(const ::std::string& value) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountAssets.asset_id)
}
#if LANG_CXX11
inline void GetAccountAssets::set_asset_id(::std::string&& value) {
  
  asset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetAccountAssets.asset_id)
}
#endif
inline void GetAccountAssets::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetAccountAssets.asset_id)
}
inline void GetAccountAssets::set_asset_id(const char* value, size_t size) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetAccountAssets.asset_id)
}
inline ::std::string* GetAccountAssets::mutable_asset_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssets.asset_id)
  return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountAssets::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssets.asset_id)
  
  return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountAssets::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id != NULL) {
    
  } else {
    
  }
  asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssets.asset_id)
}

// -------------------------------------------------------------------

// GetAccountDetail

// string account_id = 1;
inline void GetAccountDetail::clear_account_id() {
  account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountDetail::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountDetail.account_id)
  return account_id_.GetNoArena();
}
inline void GetAccountDetail::set_account_id(const ::std::string& value) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountDetail.account_id)
}
#if LANG_CXX11
inline void GetAccountDetail::set_account_id(::std::string&& value) {
  
  account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetAccountDetail.account_id)
}
#endif
inline void GetAccountDetail::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetAccountDetail.account_id)
}
inline void GetAccountDetail::set_account_id(const char* value, size_t size) {
  
  account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetAccountDetail.account_id)
}
inline ::std::string* GetAccountDetail::mutable_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountDetail.account_id)
  return account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountDetail::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountDetail.account_id)
  
  return account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountDetail::set_allocated_account_id(::std::string* account_id) {
  if (account_id != NULL) {
    
  } else {
    
  }
  account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountDetail.account_id)
}

// -------------------------------------------------------------------

// GetAssetInfo

// string asset_id = 1;
inline void GetAssetInfo::clear_asset_id() {
  asset_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAssetInfo::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAssetInfo.asset_id)
  return asset_id_.GetNoArena();
}
inline void GetAssetInfo::set_asset_id(const ::std::string& value) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAssetInfo.asset_id)
}
#if LANG_CXX11
inline void GetAssetInfo::set_asset_id(::std::string&& value) {
  
  asset_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetAssetInfo.asset_id)
}
#endif
inline void GetAssetInfo::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetAssetInfo.asset_id)
}
inline void GetAssetInfo::set_asset_id(const char* value, size_t size) {
  
  asset_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetAssetInfo.asset_id)
}
inline ::std::string* GetAssetInfo::mutable_asset_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAssetInfo.asset_id)
  return asset_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAssetInfo::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAssetInfo.asset_id)
  
  return asset_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAssetInfo::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id != NULL) {
    
  } else {
    
  }
  asset_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAssetInfo.asset_id)
}

// -------------------------------------------------------------------

// GetRoles

// -------------------------------------------------------------------

// GetRolePermissions

// string role_id = 1;
inline void GetRolePermissions::clear_role_id() {
  role_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRolePermissions::role_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetRolePermissions.role_id)
  return role_id_.GetNoArena();
}
inline void GetRolePermissions::set_role_id(const ::std::string& value) {
  
  role_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetRolePermissions.role_id)
}
#if LANG_CXX11
inline void GetRolePermissions::set_role_id(::std::string&& value) {
  
  role_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.GetRolePermissions.role_id)
}
#endif
inline void GetRolePermissions::set_role_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  role_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetRolePermissions.role_id)
}
inline void GetRolePermissions::set_role_id(const char* value, size_t size) {
  
  role_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetRolePermissions.role_id)
}
inline ::std::string* GetRolePermissions::mutable_role_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetRolePermissions.role_id)
  return role_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRolePermissions::release_role_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetRolePermissions.role_id)
  
  return role_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRolePermissions::set_allocated_role_id(::std::string* role_id) {
  if (role_id != NULL) {
    
  } else {
    
  }
  role_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetRolePermissions.role_id)
}

// -------------------------------------------------------------------

// Query_Payload

// uint64 created_time = 1;
inline void Query_Payload::clear_created_time() {
  created_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Query_Payload::created_time() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.created_time)
  return created_time_;
}
inline void Query_Payload::set_created_time(::google::protobuf::uint64 value) {
  
  created_time_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.Query.Payload.created_time)
}

// string creator_account_id = 2;
inline void Query_Payload::clear_creator_account_id() {
  creator_account_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Query_Payload::creator_account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.creator_account_id)
  return creator_account_id_.GetNoArena();
}
inline void Query_Payload::set_creator_account_id(const ::std::string& value) {
  
  creator_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Query.Payload.creator_account_id)
}
#if LANG_CXX11
inline void Query_Payload::set_creator_account_id(::std::string&& value) {
  
  creator_account_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Query.Payload.creator_account_id)
}
#endif
inline void Query_Payload::set_creator_account_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  creator_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Query.Payload.creator_account_id)
}
inline void Query_Payload::set_creator_account_id(const char* value, size_t size) {
  
  creator_account_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Query.Payload.creator_account_id)
}
inline ::std::string* Query_Payload::mutable_creator_account_id() {
  
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.creator_account_id)
  return creator_account_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Query_Payload::release_creator_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.creator_account_id)
  
  return creator_account_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query_Payload::set_allocated_creator_account_id(::std::string* creator_account_id) {
  if (creator_account_id != NULL) {
    
  } else {
    
  }
  creator_account_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), creator_account_id);
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.creator_account_id)
}

// .iroha.protocol.GetAccount get_account = 3;
inline bool Query_Payload::has_get_account() const {
  return query_case() == kGetAccount;
}
inline void Query_Payload::set_has_get_account() {
  _oneof_case_[0] = kGetAccount;
}
inline void Query_Payload::clear_get_account() {
  if (has_get_account()) {
    delete query_.get_account_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetAccount& Query_Payload::get_account() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account)
  return has_get_account()
      ? *query_.get_account_
      : ::iroha::protocol::GetAccount::default_instance();
}
inline ::iroha::protocol::GetAccount* Query_Payload::mutable_get_account() {
  if (!has_get_account()) {
    clear_query();
    set_has_get_account();
    query_.get_account_ = new ::iroha::protocol::GetAccount;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account)
  return query_.get_account_;
}
inline ::iroha::protocol::GetAccount* Query_Payload::release_get_account() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account)
  if (has_get_account()) {
    clear_has_query();
    ::iroha::protocol::GetAccount* temp = query_.get_account_;
    query_.get_account_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_account(::iroha::protocol::GetAccount* get_account) {
  clear_query();
  if (get_account) {
    set_has_get_account();
    query_.get_account_ = get_account;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_account)
}

// .iroha.protocol.GetSignatories get_account_signatories = 4;
inline bool Query_Payload::has_get_account_signatories() const {
  return query_case() == kGetAccountSignatories;
}
inline void Query_Payload::set_has_get_account_signatories() {
  _oneof_case_[0] = kGetAccountSignatories;
}
inline void Query_Payload::clear_get_account_signatories() {
  if (has_get_account_signatories()) {
    delete query_.get_account_signatories_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetSignatories& Query_Payload::get_account_signatories() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_signatories)
  return has_get_account_signatories()
      ? *query_.get_account_signatories_
      : ::iroha::protocol::GetSignatories::default_instance();
}
inline ::iroha::protocol::GetSignatories* Query_Payload::mutable_get_account_signatories() {
  if (!has_get_account_signatories()) {
    clear_query();
    set_has_get_account_signatories();
    query_.get_account_signatories_ = new ::iroha::protocol::GetSignatories;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_signatories)
  return query_.get_account_signatories_;
}
inline ::iroha::protocol::GetSignatories* Query_Payload::release_get_account_signatories() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_signatories)
  if (has_get_account_signatories()) {
    clear_has_query();
    ::iroha::protocol::GetSignatories* temp = query_.get_account_signatories_;
    query_.get_account_signatories_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_account_signatories(::iroha::protocol::GetSignatories* get_account_signatories) {
  clear_query();
  if (get_account_signatories) {
    set_has_get_account_signatories();
    query_.get_account_signatories_ = get_account_signatories;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_account_signatories)
}

// .iroha.protocol.GetAccountTransactions get_account_transactions = 5;
inline bool Query_Payload::has_get_account_transactions() const {
  return query_case() == kGetAccountTransactions;
}
inline void Query_Payload::set_has_get_account_transactions() {
  _oneof_case_[0] = kGetAccountTransactions;
}
inline void Query_Payload::clear_get_account_transactions() {
  if (has_get_account_transactions()) {
    delete query_.get_account_transactions_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetAccountTransactions& Query_Payload::get_account_transactions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_transactions)
  return has_get_account_transactions()
      ? *query_.get_account_transactions_
      : ::iroha::protocol::GetAccountTransactions::default_instance();
}
inline ::iroha::protocol::GetAccountTransactions* Query_Payload::mutable_get_account_transactions() {
  if (!has_get_account_transactions()) {
    clear_query();
    set_has_get_account_transactions();
    query_.get_account_transactions_ = new ::iroha::protocol::GetAccountTransactions;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_transactions)
  return query_.get_account_transactions_;
}
inline ::iroha::protocol::GetAccountTransactions* Query_Payload::release_get_account_transactions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_transactions)
  if (has_get_account_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetAccountTransactions* temp = query_.get_account_transactions_;
    query_.get_account_transactions_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_account_transactions(::iroha::protocol::GetAccountTransactions* get_account_transactions) {
  clear_query();
  if (get_account_transactions) {
    set_has_get_account_transactions();
    query_.get_account_transactions_ = get_account_transactions;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_account_transactions)
}

// .iroha.protocol.GetAccountAssetTransactions get_account_asset_transactions = 6;
inline bool Query_Payload::has_get_account_asset_transactions() const {
  return query_case() == kGetAccountAssetTransactions;
}
inline void Query_Payload::set_has_get_account_asset_transactions() {
  _oneof_case_[0] = kGetAccountAssetTransactions;
}
inline void Query_Payload::clear_get_account_asset_transactions() {
  if (has_get_account_asset_transactions()) {
    delete query_.get_account_asset_transactions_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetAccountAssetTransactions& Query_Payload::get_account_asset_transactions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_asset_transactions)
  return has_get_account_asset_transactions()
      ? *query_.get_account_asset_transactions_
      : ::iroha::protocol::GetAccountAssetTransactions::default_instance();
}
inline ::iroha::protocol::GetAccountAssetTransactions* Query_Payload::mutable_get_account_asset_transactions() {
  if (!has_get_account_asset_transactions()) {
    clear_query();
    set_has_get_account_asset_transactions();
    query_.get_account_asset_transactions_ = new ::iroha::protocol::GetAccountAssetTransactions;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_asset_transactions)
  return query_.get_account_asset_transactions_;
}
inline ::iroha::protocol::GetAccountAssetTransactions* Query_Payload::release_get_account_asset_transactions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_asset_transactions)
  if (has_get_account_asset_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetAccountAssetTransactions* temp = query_.get_account_asset_transactions_;
    query_.get_account_asset_transactions_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_account_asset_transactions(::iroha::protocol::GetAccountAssetTransactions* get_account_asset_transactions) {
  clear_query();
  if (get_account_asset_transactions) {
    set_has_get_account_asset_transactions();
    query_.get_account_asset_transactions_ = get_account_asset_transactions;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_account_asset_transactions)
}

// .iroha.protocol.GetTransactions get_transactions = 7;
inline bool Query_Payload::has_get_transactions() const {
  return query_case() == kGetTransactions;
}
inline void Query_Payload::set_has_get_transactions() {
  _oneof_case_[0] = kGetTransactions;
}
inline void Query_Payload::clear_get_transactions() {
  if (has_get_transactions()) {
    delete query_.get_transactions_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetTransactions& Query_Payload::get_transactions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_transactions)
  return has_get_transactions()
      ? *query_.get_transactions_
      : ::iroha::protocol::GetTransactions::default_instance();
}
inline ::iroha::protocol::GetTransactions* Query_Payload::mutable_get_transactions() {
  if (!has_get_transactions()) {
    clear_query();
    set_has_get_transactions();
    query_.get_transactions_ = new ::iroha::protocol::GetTransactions;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_transactions)
  return query_.get_transactions_;
}
inline ::iroha::protocol::GetTransactions* Query_Payload::release_get_transactions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_transactions)
  if (has_get_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetTransactions* temp = query_.get_transactions_;
    query_.get_transactions_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_transactions(::iroha::protocol::GetTransactions* get_transactions) {
  clear_query();
  if (get_transactions) {
    set_has_get_transactions();
    query_.get_transactions_ = get_transactions;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_transactions)
}

// .iroha.protocol.GetAccountAssets get_account_assets = 8;
inline bool Query_Payload::has_get_account_assets() const {
  return query_case() == kGetAccountAssets;
}
inline void Query_Payload::set_has_get_account_assets() {
  _oneof_case_[0] = kGetAccountAssets;
}
inline void Query_Payload::clear_get_account_assets() {
  if (has_get_account_assets()) {
    delete query_.get_account_assets_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetAccountAssets& Query_Payload::get_account_assets() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_assets)
  return has_get_account_assets()
      ? *query_.get_account_assets_
      : ::iroha::protocol::GetAccountAssets::default_instance();
}
inline ::iroha::protocol::GetAccountAssets* Query_Payload::mutable_get_account_assets() {
  if (!has_get_account_assets()) {
    clear_query();
    set_has_get_account_assets();
    query_.get_account_assets_ = new ::iroha::protocol::GetAccountAssets;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_assets)
  return query_.get_account_assets_;
}
inline ::iroha::protocol::GetAccountAssets* Query_Payload::release_get_account_assets() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_assets)
  if (has_get_account_assets()) {
    clear_has_query();
    ::iroha::protocol::GetAccountAssets* temp = query_.get_account_assets_;
    query_.get_account_assets_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_account_assets(::iroha::protocol::GetAccountAssets* get_account_assets) {
  clear_query();
  if (get_account_assets) {
    set_has_get_account_assets();
    query_.get_account_assets_ = get_account_assets;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_account_assets)
}

// .iroha.protocol.GetAccountDetail get_account_detail = 9;
inline bool Query_Payload::has_get_account_detail() const {
  return query_case() == kGetAccountDetail;
}
inline void Query_Payload::set_has_get_account_detail() {
  _oneof_case_[0] = kGetAccountDetail;
}
inline void Query_Payload::clear_get_account_detail() {
  if (has_get_account_detail()) {
    delete query_.get_account_detail_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetAccountDetail& Query_Payload::get_account_detail() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_detail)
  return has_get_account_detail()
      ? *query_.get_account_detail_
      : ::iroha::protocol::GetAccountDetail::default_instance();
}
inline ::iroha::protocol::GetAccountDetail* Query_Payload::mutable_get_account_detail() {
  if (!has_get_account_detail()) {
    clear_query();
    set_has_get_account_detail();
    query_.get_account_detail_ = new ::iroha::protocol::GetAccountDetail;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_detail)
  return query_.get_account_detail_;
}
inline ::iroha::protocol::GetAccountDetail* Query_Payload::release_get_account_detail() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_detail)
  if (has_get_account_detail()) {
    clear_has_query();
    ::iroha::protocol::GetAccountDetail* temp = query_.get_account_detail_;
    query_.get_account_detail_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_account_detail(::iroha::protocol::GetAccountDetail* get_account_detail) {
  clear_query();
  if (get_account_detail) {
    set_has_get_account_detail();
    query_.get_account_detail_ = get_account_detail;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_account_detail)
}

// .iroha.protocol.GetRoles get_roles = 10;
inline bool Query_Payload::has_get_roles() const {
  return query_case() == kGetRoles;
}
inline void Query_Payload::set_has_get_roles() {
  _oneof_case_[0] = kGetRoles;
}
inline void Query_Payload::clear_get_roles() {
  if (has_get_roles()) {
    delete query_.get_roles_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetRoles& Query_Payload::get_roles() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_roles)
  return has_get_roles()
      ? *query_.get_roles_
      : ::iroha::protocol::GetRoles::default_instance();
}
inline ::iroha::protocol::GetRoles* Query_Payload::mutable_get_roles() {
  if (!has_get_roles()) {
    clear_query();
    set_has_get_roles();
    query_.get_roles_ = new ::iroha::protocol::GetRoles;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_roles)
  return query_.get_roles_;
}
inline ::iroha::protocol::GetRoles* Query_Payload::release_get_roles() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_roles)
  if (has_get_roles()) {
    clear_has_query();
    ::iroha::protocol::GetRoles* temp = query_.get_roles_;
    query_.get_roles_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_roles(::iroha::protocol::GetRoles* get_roles) {
  clear_query();
  if (get_roles) {
    set_has_get_roles();
    query_.get_roles_ = get_roles;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_roles)
}

// .iroha.protocol.GetRolePermissions get_role_permissions = 11;
inline bool Query_Payload::has_get_role_permissions() const {
  return query_case() == kGetRolePermissions;
}
inline void Query_Payload::set_has_get_role_permissions() {
  _oneof_case_[0] = kGetRolePermissions;
}
inline void Query_Payload::clear_get_role_permissions() {
  if (has_get_role_permissions()) {
    delete query_.get_role_permissions_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetRolePermissions& Query_Payload::get_role_permissions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_role_permissions)
  return has_get_role_permissions()
      ? *query_.get_role_permissions_
      : ::iroha::protocol::GetRolePermissions::default_instance();
}
inline ::iroha::protocol::GetRolePermissions* Query_Payload::mutable_get_role_permissions() {
  if (!has_get_role_permissions()) {
    clear_query();
    set_has_get_role_permissions();
    query_.get_role_permissions_ = new ::iroha::protocol::GetRolePermissions;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_role_permissions)
  return query_.get_role_permissions_;
}
inline ::iroha::protocol::GetRolePermissions* Query_Payload::release_get_role_permissions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_role_permissions)
  if (has_get_role_permissions()) {
    clear_has_query();
    ::iroha::protocol::GetRolePermissions* temp = query_.get_role_permissions_;
    query_.get_role_permissions_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_role_permissions(::iroha::protocol::GetRolePermissions* get_role_permissions) {
  clear_query();
  if (get_role_permissions) {
    set_has_get_role_permissions();
    query_.get_role_permissions_ = get_role_permissions;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_role_permissions)
}

// .iroha.protocol.GetAssetInfo get_asset_info = 12;
inline bool Query_Payload::has_get_asset_info() const {
  return query_case() == kGetAssetInfo;
}
inline void Query_Payload::set_has_get_asset_info() {
  _oneof_case_[0] = kGetAssetInfo;
}
inline void Query_Payload::clear_get_asset_info() {
  if (has_get_asset_info()) {
    delete query_.get_asset_info_;
    clear_has_query();
  }
}
inline  const ::iroha::protocol::GetAssetInfo& Query_Payload::get_asset_info() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_asset_info)
  return has_get_asset_info()
      ? *query_.get_asset_info_
      : ::iroha::protocol::GetAssetInfo::default_instance();
}
inline ::iroha::protocol::GetAssetInfo* Query_Payload::mutable_get_asset_info() {
  if (!has_get_asset_info()) {
    clear_query();
    set_has_get_asset_info();
    query_.get_asset_info_ = new ::iroha::protocol::GetAssetInfo;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_asset_info)
  return query_.get_asset_info_;
}
inline ::iroha::protocol::GetAssetInfo* Query_Payload::release_get_asset_info() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_asset_info)
  if (has_get_asset_info()) {
    clear_has_query();
    ::iroha::protocol::GetAssetInfo* temp = query_.get_asset_info_;
    query_.get_asset_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Query_Payload::set_allocated_get_asset_info(::iroha::protocol::GetAssetInfo* get_asset_info) {
  clear_query();
  if (get_asset_info) {
    set_has_get_asset_info();
    query_.get_asset_info_ = get_asset_info;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.get_asset_info)
}

// uint64 query_counter = 13;
inline void Query_Payload::clear_query_counter() {
  query_counter_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Query_Payload::query_counter() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.query_counter)
  return query_counter_;
}
inline void Query_Payload::set_query_counter(::google::protobuf::uint64 value) {
  
  query_counter_ = value;
  // @@protoc_insertion_point(field_set:iroha.protocol.Query.Payload.query_counter)
}

inline bool Query_Payload::has_query() const {
  return query_case() != QUERY_NOT_SET;
}
inline void Query_Payload::clear_has_query() {
  _oneof_case_[0] = QUERY_NOT_SET;
}
inline Query_Payload::QueryCase Query_Payload::query_case() const {
  return Query_Payload::QueryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Query

// .iroha.protocol.Query.Payload payload = 1;
inline bool Query::has_payload() const {
  return this != internal_default_instance() && payload_ != NULL;
}
inline void Query::clear_payload() {
  if (GetArenaNoVirtual() == NULL && payload_ != NULL) delete payload_;
  payload_ = NULL;
}
inline const ::iroha::protocol::Query_Payload& Query::payload() const {
  const ::iroha::protocol::Query_Payload* p = payload_;
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.payload)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Query_Payload*>(
      &::iroha::protocol::_Query_Payload_default_instance_);
}
inline ::iroha::protocol::Query_Payload* Query::mutable_payload() {
  
  if (payload_ == NULL) {
    payload_ = new ::iroha::protocol::Query_Payload;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.payload)
  return payload_;
}
inline ::iroha::protocol::Query_Payload* Query::release_payload() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.payload)
  
  ::iroha::protocol::Query_Payload* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline void Query::set_allocated_payload(::iroha::protocol::Query_Payload* payload) {
  delete payload_;
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.payload)
}

// .iroha.protocol.Signature signature = 2;
inline bool Query::has_signature() const {
  return this != internal_default_instance() && signature_ != NULL;
}
inline void Query::clear_signature() {
  if (GetArenaNoVirtual() == NULL && signature_ != NULL) delete signature_;
  signature_ = NULL;
}
inline const ::iroha::protocol::Signature& Query::signature() const {
  const ::iroha::protocol::Signature* p = signature_;
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.signature)
  return p != NULL ? *p : *reinterpret_cast<const ::iroha::protocol::Signature*>(
      &::iroha::protocol::_Signature_default_instance_);
}
inline ::iroha::protocol::Signature* Query::mutable_signature() {
  
  if (signature_ == NULL) {
    signature_ = new ::iroha::protocol::Signature;
  }
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.signature)
  return signature_;
}
inline ::iroha::protocol::Signature* Query::release_signature() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.signature)
  
  ::iroha::protocol::Signature* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void Query::set_allocated_signature(::iroha::protocol::Signature* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.signature)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protocol
}  // namespace iroha

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_queries_2eproto__INCLUDED
